'////////////////////////////////////////////////////////
'              THIS SCRIPT IS AUTOGENERATED
'     by indexing/create_LoadScriptsBootstrap_vbs.pl
'                     DO NOT MODIFY
'////////////////////////////////////////////////////////

'
' #######################
' BEGIN: ../Framework/Tools/Script Management/LoadScripts.vbs

'[path=\Framework\Tools\Script Management]
'[group=Script Management]

option explicit

!INC Local Scripts.EAConstants-VBScript
'
' #######################
' BEGIN: ../Framework/Wrappers/Include.vbs

'[path=\Framework\Wrappers]
'[group=Wrappers]

'include all individual scripts in this group
'
' #######################
' BEGIN: ../Framework/Wrappers/Scripting/Script.vbs

'[path=\Framework\Wrappers\Scripting]
'[group=Wrappers]



'
' #######################
' BEGIN: ../Framework/Utils/Include.vbs

'[path=\Framework\Utils]
'[group=Utils]
'
' #######################
' BEGIN: ../Framework/Utils/BinaryFile.vbs

'[path=\Framework\Utils]
'[group=Utils]
'Author: Geert Bellekens
'Date: 2015-12-07
' Already inlined !INC Utils.Include

Const adTypeBinary = 1
Const adSaveCreateOverWrite = 2

Class BinaryFile
	Private m_FullPath
	Private m_Contents
	Private m_Folder
	Private m_FileName
	
	Private Sub Class_Initialize
	  set m_Folder = Nothing
	  m_FileName = ""
	  m_Contents = ""
	End Sub
	
	' FullPath property.
	Public Property Get FullPath
	  FullPath = me.Folder.FullPath & "\" & me.FileName
	End Property	
	public Property Let FullPath(value)
	  dim startBackslash
	  startBackslash = InstrRev(value, "\", -1, 1)
	  me.Folder.FullPath = left(value, startBackslash -1) 'get everything before the last "\"
	  me.FileName = mid(value, startBackslash + 1) 'get everything after the last "."
	end Property
		
	' Contents property, should be a array of bytes.
	Public Property Get Contents
	  Contents = m_Contents
	End Property
	Public Property Let Contents(value)
	  m_Contents = value
	End Property
	
	' FileName property.
	Public Property Get FileName
	  FileName = m_FileName
	End Property
	Public Property Let FileName(value)
	  m_FileName = value
	End Property
	' FileNameWithoutExtension property.
	Public Property Get FileNameWithoutExtension
	  dim startExtension
	  startExtension = InstrRev(me.FileName, ".", -1, 1)
	  FileNameWithoutExtension = left(me.FileName, startExtension -1) 'get everything before the last "."
	End Property
	' Extension property.
	Public Property Get Extension
	  dim startExtension
	  startExtension = InstrRev(me.FileName, ".", -1, 1)
	  Extension = mid(me.FileName, startExtension + 1) 'get everything after the last "."
	End Property
	
	' Folder property.
	Public Property Get Folder
	  if m_Folder is nothing then
		set m_Folder = new FileSystemFolder
	  end if
	  set Folder = m_Folder
	End Property
	Public Property Let Folder(value)
	  set m_Folder = value
	End Property
	
	'save the file to disk
	sub Save
		'first make sure the directory exists
		me.Folder.Save
		'then create file	
		'Create Stream object
		Dim BinaryStream
		Set BinaryStream = CreateObject("ADODB.Stream")
		'Specify stream type ï¿½ we want To save binary data.
		BinaryStream.Type = adTypeBinary
		'Open the stream And write binary data To the object
		BinaryStream.Open
		BinaryStream.Write Contents
		'Save binary data To disk
		BinaryStream.SaveToFile me.FullPath, adSaveCreateOverWrite
	end sub
	
	'delete the file
	sub Delete
		Dim fso
		Set fso = CreateObject("Scripting.FileSystemObject")
		if fso.FileExists(me.FullPath) then
			fso.DeleteFile me.FullPath
		end if
	end sub

end class
'
' END: ../Framework/Utils/BinaryFile.vbs
' #######################

'
' #######################
' BEGIN: ../Framework/Utils/DocGenHelpers.vbs

'[path=\Framework\Utils]
'[group=Utils]
' Script Name: DocGenHelpers
' Author: Geert Bellekens
' Purpose: serves as library for other scripts for document generation
' Date: 2017-02-16


function addMasterDocument (packageGUID, documentName)
	dim domainName
	dim splittedDocumentName
	splittedDocumentName = Split(documentName)
	domainName = splittedDocumentName(Ubound(splittedDocumentName))
	dim ownerPackage as EA.Package
	set ownerPackage = Repository.GetPackageByGuid(packageGUID)
	dim masterDocumentPackage as EA.Package
	set masterDocumentPackage = ownerPackage.Packages.AddNew(documentName, "package")
	masterDocumentPackage.Update
	masterDocumentPackage.Element.Stereotype = "master document"
	masterDocumentPackage.Alias = domainName
	masterDocumentPackage.Update
	'link to the master template
	dim templateTag as EA.TaggedValue
	for each templateTag in masterDocumentPackage.Element.TaggedValues
		if templateTag.Name = "RTFTemplate" then
			templateTag.Value = "(model document: master template)"
			templateTag.Notes = "Default: (model document: master template)"
			templateTag.Update
			exit for
		end if
	next
	'return
	set addMasterDocument = masterDocumentPackage
end function

function removeMasterDocumentDuplicates(packageGUID, masterDocumentName)
	dim requireUserLock
	requireUserLock = isRequireUserLockEnabled()
	dim canDelete
	canDelete = true
	dim package AS EA.Package
	set package = Repository.GetPackageByGuid(packageGUID)
	'Remove the packages that start with the masterDocumentName
	dim masterDocument as EA.Package
	dim i
	'turn off error handling
	on error resume next
	for i = package.Packages.Count -1 to 0 step -1
		set masterDocument = package.Packages(i)
		if len(masterDocumentName) <= len(masterDocument.Name) then
			if requireUserLock then
				canDelete = masterDocument.ApplyUserLockRecursive(true, true, true)
			end if
			'if the first part is equal then delete it
			if canDelete _
				and left(masterDocument.Name, len(masterDocumentName)) = masterDocumentName then
				'delete the package
				package.Packages.DeleteAt i,false
			end if
		end if
	next
	'turn error handling back on
	on error goto 0
end function

'improved version of the addMasterDocumentWithDetails using the tagged values
function addMasterDocumentWithDetailTags (packageGUID,masterDocumentName,documentAlias,documentName,documentTitle,documentVersion,documentStatus)
	dim ownerPackage as EA.Package
	set ownerPackage = Repository.GetPackageByGuid(packageGUID)
	dim masterDocumentPackage as EA.Package
	if isRequireUserLockEnabled then
		ownerPackage.ApplyUserLock
	end if
	set masterDocumentPackage = ownerPackage.Packages.AddNew(masterDocumentName, "package")
	masterDocumentPackage.Update
	masterDocumentPackage.Element.Stereotype = "master document"
	masterDocumentPackage.Update
	'link to the master template
	dim templateTag as EA.TaggedValue
	for each templateTag in masterDocumentPackage.Element.TaggedValues
		select case templateTag.Name 
			case "RTFTemplate" 
				templateTag.Value = "(model document: master template)"
				templateTag.Notes = "Default: (model document: master template)"
			case "ReportAlias"
				templateTag.Value = documentAlias
			case "ReportAuthor"
				templateTag.Value = masterDocumentPackage.Element.Author
			case "ReportName"
				templateTag.Value = documentName
			case "ReportTitle"
				templateTag.Value = documentTitle
			case "ReportVersion"
				templateTag.Value = documentVersion
			case "ReportStatus"
				templateTag.Value = documentStatus
		end select
		'save changed
		templateTag.Update
	next
	'return
	set addMasterDocumentWithDetailTags = masterDocumentPackage
end function

function addMasterDocumentWithDetails (packageGUID, documentName,documentVersion,documentAlias)
	dim ownerPackage as EA.Package
	set ownerPackage = Repository.GetPackageByGuid(packageGUID)
	dim masterDocumentPackage as EA.Package
	set masterDocumentPackage = ownerPackage.Packages.AddNew(documentName, "package")
	masterDocumentPackage.Update
	masterDocumentPackage.Element.Stereotype = "master document"
	masterDocumentPackage.Alias = documentAlias
	masterDocumentPackage.Version = documentVersion
	masterDocumentPackage.Update
	'link to the master template
	dim templateTag as EA.TaggedValue
	for each templateTag in masterDocumentPackage.Element.TaggedValues
		if templateTag.Name = "RTFTemplate" then
			templateTag.Value = "(model document: master template)"
			templateTag.Notes = "Default: (model document: master template)"
			templateTag.Update
			exit for
		end if
	next
	'return
	set addMasterDocumentWithDetails = masterDocumentPackage
end function

function addModelDocumentForDiagram(masterDocument,diagram, treepos, template)
	dim diagramPackage as EA.Package
	set diagramPackage = Repository.GetPackageByID(diagram.PackageID)
	addModelDocumentForPackage masterDocument,diagramPackage,diagram.Name & " diagram", treepos, template
end function

function addModelDocumentForPackage(masterDocument,package,name, treepos, template)
	dim modelDocElement as EA.Element
	set modelDocElement = masterDocument.Elements.AddNew(name, "Class")
	'set the position
	modelDocElement.TreePos = treepos
	modelDocElement.StereotypeEx = "model document"
	modelDocElement.Update
	'add tagged values
	dim templateTag as EA.TaggedValue
	for each templateTag in modelDocElement.TaggedValues
		if templateTag.Name = "RTFTemplate" then
			templateTag.Value = template
			templateTag.Notes = "Default: Model Report"
			templateTag.Update
			exit for
		end if
	next
	'add attribute
	dim attribute as EA.Attribute
	set attribute = modelDocElement.Attributes.AddNew(package.Name, "Package")
	attribute.ClassifierID = package.Element.ElementID
	attribute.Update
end function

function addModelDocument(masterDocument, template,elementName, elementGUID, treepos)
	addModelDocumentWithSearch masterDocument, template,elementName, elementGUID, treepos,"ZDG_ElementByGUID"
end function


function addModelDocumentWithSearch(masterDocument, template,elementName, elementGUID, treepos, searchName)
	dim modelDocElement as EA.Element;
	set modelDocElement = masterDocument.Elements.AddNew(elementName, "Class")
	'set the position
	modelDocElement.TreePos = treepos
	modelDocElement.StereotypeEx = "model document"
	modelDocElement.Update
	dim templateTag as EA.TaggedValue
	if len(elementGUID) > 0 then
		for each templateTag in modelDocElement.TaggedValues
			if templateTag.Name = "RTFTemplate" then
				templateTag.Value = template
				templateTag.Notes = "Default: Model Report"
				templateTag.Update
			elseif templateTag.Name = "SearchName" then
				templateTag.Value = searchName
				templateTag.Update
			elseif templateTag.Name = "SearchValue" then
				templateTag.Value = elementGUID
				templateTag.Update
			end if
		next
	else
		'add tagged values
		for each templateTag in modelDocElement.TaggedValues
			if templateTag.Name = "RTFTemplate" then
				templateTag.Value = template
				templateTag.Notes = "Default: Model Report"
				templateTag.Update
				exit for
			end if
		next
		'no GUID provided. Set masterdocument package ID as dummy attribute to make the template work
		dim attribute as EA.Attribute
		set attribute = modelDocElement.Attributes.AddNew(masterDocument.Name, "Package")
		attribute.ClassifierID = masterDocument.Element.ElementID
		attribute.Update
	end if
end function

function getApplication(selectedElement)
	getApplication = "CMS" 'default name
	dim rootPackage as EA.Package
	set rootPackage = getRootPackage(selectedElement)
	if not rootPackage is nothing then
		dim applicationName
		applicationName = Replace(rootPackage.Name,"Application ","")
		if len(applicationName) > 0 then
			getApplication = applicationName
		end if
	end if
end function
'
' END: ../Framework/Utils/DocGenHelpers.vbs
' #######################

'
' #######################
' BEGIN: ../Framework/Utils/ExcelFile.vbs

'[path=\Framework\Utils]
'[group=Utils]

'Name: ExcelFile
'Author: Geert Bellekens
'Purpose: Wrapper script class for Excel files
'Date: 2017-03-20

' Already inlined !INC Utils.Include

const xlCalculationAutomatic	= -4105	'Excel controls recalculation.
const xlCalculationManual		= -4135	'Calculation is done when the user requests it.
const xlCenter 					= -4108
const xlLeft 					= -4131
const xlBelow 					= 1
const xlAbove 					= 0
'vertical alignment values
const xlVAlignBottom 			= -4107	'Bottom
const xlVAlignCenter	 		= -4108	'Center
const xlVAlignDistributed 		= -4117	'Distributed
const xlVAlignJustify 			= -4130	'Justify
const xlVAlignTop 				= -4160	'Top
'XlFormatConditionType 
const xlAboveAverageCondition	= 12 'Above average condition
const xlBlanksCondition			= 10 'Blanks condition
const xlCellValue				= 1	 'Cell value
const xlColorScale				= 3	 'Color scale
const xlDataBar					= 4	 'DataBar
const xlErrorsCondition			= 16 'Errors condition
const xlExpression				= 2	 'Expression
const xlIconSet					= 6	 'Icon set
const xlNoBlanksCondition		= 13 'No blanks condition
const xlNoErrorsCondition		= 17 'No errors condition
const xlTextString				= 9	 'Text string
const xlTimePeriod				= 11 'Time period
const xlTop10					= 5	 'Top 10 values
const xlUniqueValues			= 8	 'Unique values
'XlFormatConditionOperator 
const xlBetween		 = 1	'Between. Can be used only if two formulas are provided.
const xlEqual		 = 3	'Equal.
const xlGreater		 = 5	'Greater than.
const xlGreaterEqual = 7	'Greater than or equal to.
const xlLess		 = 6	'Less than.
const xlLessEqual	 = 8	'Less than or equal to.
const xlNotBetween	 = 2	'Not between. Can be used only if two formulas are provided.
const xlNotEqual	 = 4	'Not equal.
'XlWindowState
const xlMaximized	 = -4137	'Maximized
const xlMinimized	 = -4140	'Minimized
const xlNormal		 = -4143	'Normal

Class ExcelFile
	'private variables
	Private m_ExcelApp
	Private m_FileName
	Private m_WorkBook
	private m_isExisting

	Private Sub Class_Initialize
		m_FileName = ""
		set m_ExcelApp = CreateObject("Excel.Application")
		set m_WorkBook = nothing
		m_isExisting = false
	End Sub
	
	
	' FileName property.
	Public Property Get FileName
	  FileName = m_FileName
	End Property
	Public Property Let FileName(value)
	  m_FileName = value
	End Property
	public Property Get worksheets
		set worksheets = m_WorkBook.Sheets
	end property
	
	public function freezePanes(ws, row, column)
		'select the worksheet
		ws.Activate
		m_ExcelApp.ActiveWindow.WindowState = xlMaximized
		m_ExcelApp.ActiveWindow.SplitRow = row
		m_ExcelApp.ActiveWindow.SplitColumn = column
		m_ExcelApp.ActiveWindow.FreezePanes = true
	end function
	
	
	private function createNewTab(tabName,beforeSheetIndex)
		'check if the workbook has been created already
		if m_WorkBook is nothing then
			set m_WorkBook = m_ExcelApp.Workbooks.Add()
		end if
		Dim ws
		set ws = nothing
		dim currentWs
		'check if it exists
		for each currentWs in m_WorkBook.Sheets
			if currentWs.Name = tabName then
				set ws = currentWs
				exit for
			end if
		next
		'if not exist yet then create
		if ws is nothing then
			'check the beforeIndex. In -1 then add in the back
			if beforeSheetIndex > 0 and beforeSheetIndex <= m_Workbook.Sheets.Count then
				Set ws = m_WorkBook.Sheets.Add(m_Workbook.Sheets(beforeSheetIndex)) 'add before the given sheetIndex
			else
				Set ws = m_WorkBook.Sheets.Add(,m_Workbook.Sheets(m_Workbook.Sheets.Count)) 'add after the last one
			end if
			ws.Name = tabName
		end if
		'return
		set createNewTab = ws
	end function 
		
	'public operations
	'create a tab with the given name. The contents should parameter should be a two dimensional array
	'anything int he contents that starts with "=" will be interpreted as a formula
	public Function createTabWithFormulas(tabName, contents,formatAsTable, tableStyle, beforeSheetIndex)
		'turn off automatic calculation
		m_ExcelApp.Calculation = xlCalculationManual
		'create the tab
		Dim ws
		set ws = createNewTab(tabName,beforeSheetIndex)
		'fill the contents
		'loop content
		dim i
		dim j
		for i = 0 to Ubound(contents,1)
			for j = 0 to Ubound(Contents,2)
				dim cellValue
				cellValue = contents(i,j)
				if left(cellValue,1) = "=" then
					ws.Cells(i + 1,j + 1).Formula = cellValue
				else
					ws.Cells(i + 1,j + 1).Value = cellValue
				end if
			next
		next
		dim targetRange
		set targetRange = ws.Range(ws.Cells(1,1), ws.Cells(Ubound(contents,1) +1, Ubound(Contents,2) +1))
		'format as table if needed
		if formatAsTable then
			formatSheetAsTable ws, targetRange, tableStyle
		end if
		'set autofit
		targetRange.Columns.Autofit
		targetRange.Rows.Autofit
		'turn on automatic calculation
		m_ExcelApp.Calculation = xlCalculationAutomatic
	end function
	'public operations
	'create a tab with the given name. The contents should parameter should be a two dimensional array
	public Function createTab(tabName, contents,formatAsTable, tableStyle)
		'return 
		set createTab = createTabAtIndex(tabName, contents,formatAsTable, tableStyle, -1)
	end function
	
	public function createTabAtIndex(tabName, contents,formatAsTable, tableStyle, beforeSheetIndex)
		'create the tab
		Dim ws
		set ws = createNewTab(tabName,beforeSheetIndex)
		'fill the contents
		dim targetRange
		set targetRange = ws.Range(ws.Cells(1,1), ws.Cells(Ubound(contents,1) +1, Ubound(Contents,2) +1))
		targetRange.Value2 = contents
		'format as table if needed
		if formatAsTable then
			formatSheetAsTable ws, targetRange, tableStyle
		end if
		'set autofit
		targetRange.Columns.Autofit
		targetRange.Rows.Autofit
		'return 
		set createTabAtIndex = ws
	end function
	
		
	public function formatSheetAsTable(worksheet, targetRange, tableStyle)
		dim table
		Set table = worksheet.ListObjects.Add(1, targetRange, 1, 1)
		table.TableStyle = tableStyle
	end function
	
	public Function getUserSelectedFileName()
		dim selectedFileName
		dim project
		set project = Repository.GetProjectInterface()
		me.FileName = project.GetFileNameDialog ("", "Excel Files|*.xls;*.xlsx;*.xlsm", 1, 2 ,"", 1) 'save as with overwrite prompt: OFN_OVERWRITEPROMPT
	end function
	
	public Function openUserSelectedFile()
		dim selectedFileName
		dim project
		set project = Repository.GetProjectInterface()
		me.FileName = project.GetFileNameDialog ("", "Excel Files|*.xls;*.xlsx;*.xlsm|Excel Templates|*.xlt;*.xltx;*.xltm", 1, 0 ,"", 0) 'save as with overwrite prompt: OFN_OVERWRITEPROMPT
		Dim fso
		Set fso = CreateObject("Scripting.FileSystemObject")
		if fso.FileExists(me.FileName) then
			'check the extension
			dim extension
			extension = lcase(fso.GetExtensionName(me.FileName))
			select case extension
				case "xlt","xltx","xltm"
					me.NewFile me.FileName
				case else
					me.Open me.FileName
					m_isExisting = true
			end select
		end if
	end function
	
	public function Open(filePath)
		me.FileName = filePath
		set m_WorkBook = m_ExcelApp.Workbooks.Open(me.FileName)
	end function
	
	public function NewFile(filePath)
		dim fso
		Set fso = CreateObject("Scripting.FileSystemObject")
		if fso.FileExists(filePath) then
			set m_WorkBook = m_ExcelApp.Workbooks.Add(filePath)
		end if
		'reset filename
		me.FileName = ""
	end function
	
	public function formatRange (range, backColor, fontColor, fontName, fontSize, bold, horizontalAlignment)
		if backColor <> "default" then 
			range.Interior.Color = backColor 
		end if
		if fontColor <> "default" then
			range.Font.Color = fontColor
		end if
		if fontName <> "default" then
			range.Font.Name = fontName
		end if
		if fontSize <> "default" then
			range.Font.Size = fontSize
		end if
		if horizontalAlignment <> "default" then
			range.HorizontalAlignment = horizontalAlignment
		end if
	end function
	
	public function hideColumn(sheet, columnNumber)
		sheet.Columns(columnNumber).Hidden = true
	end function
	
	public function setVerticalAlignment(range, verticalAlignment)
		range.VerticalAlignment = verticalAlignment
	end function
	
	public function getContents(sheet)
		getContents = sheet.UsedRange.Value2
	end function
	
	public function addConditionalFormatting(range, formattingType, operator , formula1, formula2, backColor)
		dim formatting
		set formatting = range.FormatConditions.Add(formattingType, operator , formula1, formula2)
		formatting.Interior.Color = backColor
	end function
	
	public Function save()
		'make sure we have a filename
		if len(me.FileName) = 0 then
			getUserSelectedFileName
		end if
		'if the file name is still empty then exit
		if len(me.FileName) = 0 then
			exit function
		end if
		if m_isExisting then
			m_WorkBook.Save
		else
			'Delete the existing file if it exists
			dim fso
			Set fso = CreateObject("Scripting.FileSystemObject")
			if fso.FileExists(me.FileName) then
				fso.DeleteFile me.FileName
			end if
			'save the workbook at the given filename
			m_WorkBook.Saveas me.FileName
		end if
		'make excel visible
		m_ExcelApp.visible = True
		m_ExcelApp.WindowState = -4137 'xlMaximized
	end function
	
	
end Class
'
' END: ../Framework/Utils/ExcelFile.vbs
' #######################

'
' #######################
' BEGIN: ../Framework/Utils/FileSystem.vbs

'[path=\Framework\Utils]
'[group=Utils]

'
' Script Name: FileSystem
' Author: Geert Bellekens
' Purpose: A collection of useful functions related to the file system
' Date: 2016-06-18
'
function getTempFilename()
	Dim fso
	Set fso = CreateObject("Scripting.FileSystemObject")
	Dim tfolder, tname
	Const TemporaryFolder = 2
	Set tfolder = fso.GetSpecialFolder(TemporaryFolder)
	tname = fso.GetTempName    
	getTempFilename = tfolder &"\"& tname
End Function

function unzip (zipfile)
	'The folder the contents should be extracted to.
	dim extractTo, fso, filename, foldername
	Set fso = CreateObject("Scripting.FileSystemObject")
	filename = fso.GetFileName(zipfile)
	foldername = Replace(FileName, ".zip", "")
	extractTo = fso.GetParentFolderName(zipfile) & "\" & foldername
	
	'If the extraction location does not exist create it.
	If NOT fso.FolderExists(extractTo) Then
	   fso.CreateFolder(extractTo)
	End If

	'Extract the contents of the zip file.
	set objShell = CreateObject("Shell.Application")
	dim filesInZip
	set FilesInZip = objShell.NameSpace(zipfile).items
	objShell.NameSpace(extractTo).CopyHere(filesInZip)
	
	'clear objects
	Set fso = Nothing
	Set objShell = Nothing
	
	'return folder name
	unzip = extractTo
end function

Function ChooseFile (ByVal initialDir, filter)

	dim shell, fso, tempdir, tempfile, powershellfile, powershellOutputFile,psScript, textFile
	Set shell = CreateObject("WScript.Shell")

	Set fso = CreateObject("Scripting.FileSystemObject")

	tempDir = shell.ExpandEnvironmentStrings("%TEMP%")

	tempFile = tempDir & "\" & fso.GetTempName

	' temporary powershell script file to be invoked
	powershellFile = tempFile & ".ps1"

	' temporary file to store standard output from command
	powershellOutputFile = tempFile & ".txt"

	'if the filter is empty we use all files
	if len(filter) = 0 then
	filter = "All Files (*.*)|*.*"
	end if

	'input script
	psScript = psScript & "[System.Reflection.Assembly]::LoadWithPartialName(""System.windows.forms"") | Out-Null" & vbCRLF
	psScript = psScript & "$dlg = New-Object System.Windows.Forms.OpenFileDialog" & vbCRLF
	psScript = psScript & "$dlg.initialDirectory = """ &initialDir & """" & vbCRLF
	'psScript = psScript & "$dlg.filter = ""ZIP files|*.zip|Text Documents|*.txt|Shell Scripts|*.*sh|All Files|*.*""" & vbCRLF
	psScript = psScript & "$dlg.filter = """ & filter & """" & vbCRLF
	' filter index 4 would show all files by default
	' filter index 1 would should zip files by default
	psScript = psScript & "$dlg.FilterIndex = 1" & vbCRLF
	psScript = psScript & "$dlg.Title = ""Select a file""" & vbCRLF
	psScript = psScript & "$dlg.ShowHelp = $True" & vbCRLF
	psScript = psScript & "$dlg.ShowDialog() | Out-Null" & vbCRLF
	psScript = psScript & "Set-Content """ &powershellOutputFile & """ $dlg.FileName" & vbCRLF
	'MsgBox psScript

	Set textFile = fso.CreateTextFile(powershellFile, True)
	textFile.WriteLine(psScript)
	textFile.Close
	Set textFile = Nothing

	' objShell.Run (strCommand, [intWindowStyle], [bWaitOnReturn]) 
	' 0 Hide the window and activate another window.
	' bWaitOnReturn set to TRUE - indicating script should wait for the program 
	' to finish executing before continuing to the next statement

	Dim appCmd
	appCmd = "powershell -ExecutionPolicy unrestricted &'" & powershellFile & "'"
	'MsgBox appCmd
	shell.Run appCmd, 0, TRUE

	' open file for reading, do not create if missing, using system default format
	Set textFile = fso.OpenTextFile(powershellOutputFile, 1, 0, -2)
	ChooseFile = textFile.ReadLine
	textFile.Close
	Set textFile = Nothing
	fso.DeleteFile(powershellFile)
	fso.DeleteFile(powershellOutputFile)

End Function

Function cleanFileName(fileName)
	Dim regEx
	Set regEx = CreateObject("VBScript.RegExp")

	regEx.IgnoreCase = True
	regEx.Global = True
	regEx.Pattern = "[(?*"",\\<>&#~%{}+@:\/!;]+"
	cleanFileName = regEx.Replace(fileName, "-")
end function
'
' END: ../Framework/Utils/FileSystem.vbs
' #######################

'
' #######################
' BEGIN: ../Framework/Utils/FileSystemFolder.vbs

'[path=\Framework\Utils]
'[group=Utils]

'Author: Geert Bellekens
'Date: 2015-12-07



!INC Local Scripts.EAConstants-VBScript
' Already inlined !INC Utils.Include

Const ForReading = 1, ForWriting = 2, ForAppending = 8
Const TristateUseDefault = -2, TristateTrue = -1, TristateFalse = 0

Class FileSystemFolder
	Private m_ParentPath
	Private m_Name
	
	' Name property.
	Public Property Get Name
	  Name = m_Name
	End Property
	Public Property Let Name(value)
	  m_Name = value
	End Property
	
	' FullPath property.
	Public Property Get FullPath
	  FullPath = m_ParentPath & "\" & Name
	End Property
	Public Property Let FullPath(value)
	  dim nameStart
	  nameStart = InstrRev(value, "\", -1, 0) 
	  m_ParentPath = left(value,nameStart -1)
	  m_Name = mid(value,NameStart +1)
	End Property
	
	'parentFolder
	Public Property Get ParentFolder
		set ParentFolder = nothing
		if len(m_ParentPath) > 0 and right(m_ParentPath,2) <> ":\" then
			set ParentFolder = new FileSystemFolder
			ParentFolder.FullPath = m_ParentPath
		end if
	End Property
	
	' TextFiles property
	Public Property Get TextFiles
		dim fso, fsoFolder, files, file, result, v_textFile, ts
		set result = CreateObject("System.Collections.ArrayList")
		Set fso = CreateObject("Scripting.FileSystemObject")
		if fso.FolderExists(me.FullPath) then
			Set fsoFolder = fso.GetFolder(me.FullPath)			
			Set files = fsoFolder.Files
			For Each file in files
				set v_textFile = new TextFile
				v_textFile.Folder = me
				v_textFile.FileName = file.Name
                                v_textFile.loadContents()
				result.add v_textFile
			Next
		end if
		set TextFiles = result
	End Property
	
	'SubFolders property
	public property Get SubFolders
		Dim fso, result, folders, tempfolder, subfolder, folder
		set result = CreateObject("System.Collections.ArrayList")
		Set fso = CreateObject("Scripting.FileSystemObject")
		Set tempfolder = fso.GetFolder(me.FullPath)
		Set folders = tempfolder.SubFolders
		For Each folder in folders
			set subfolder = new FileSystemFolder
			subFolder.FullPath = folder.Path
			result.Add subFolder
		Next
		set SubFolders = result
	End Property
	'let the user select a folder, optionally from a given starting path.
	public function getUserSelectedFolder(startPath)
		dim folder, shell
		Set shell  = CreateObject( "Shell.Application" )
		if len(startPath) > 0 then
			Set folder = shell.BrowseForFolder( 0, "Select Folder", 0,startPath)
		else
			Set folder = shell.BrowseForFolder( 0, "Select Folder", 0)
		end if
		if not folder is nothing then
			set getUserSelectedFolder = New FileSystemFolder
			getUserSelectedFolder.FullPath = folder.Self.Path 
		else
			set getUserSelectedFolder = Nothing
		end if
	end function
	'save the folder
	public sub Save()
		Dim fso
		Set fso = CreateObject("Scripting.FileSystemObject")
		'first check if the path doesn't exist yet
		if not fso.FolderExists(me.FullPath) and len(me.FullPath) > 1 then
			if not me.ParentFolder is nothing then
				me.ParentFolder.Save
			end if
			fso.CreateFolder me.FullPath
		end if
	end sub
	'delete the folder
	public sub Delete()
		Dim fso
		Set fso = CreateObject("Scripting.FileSystemObject")
		if fso.FolderExists(me.FullPath) then
			fso.DeleteFolder me.FullPath
		end if
	end sub
End Class
'
' END: ../Framework/Utils/FileSystemFolder.vbs
' #######################

'
' #######################
' BEGIN: ../Framework/Utils/ModelInfo.vbs

'[path=\Framework\Utils]
'[group=Utils]
'Author: Geert Bellekens
'Date: 2016-01-08

'sub test
'	dim selectedElement, fqn
'	set selectedElement = Repository.GetContextObject()
'	fqn = getFullyQualifiedName(selectedElement)
'	Session.Output "FQN: " & fqn
'end sub
'test

'TODO: use caching to speed up the process
Dim elementCache 	
dim packageCache
'initialise the cache objects
init

Private Sub Module_Initialize()
	'the cache contains the ID (package or element ID) and the fully qualified name of the element or package.
	'this only seems to work in debug mode for some reason?
'	set elementCache = CreateObject("Scripting.Dictionary")
'	set packageCache = CreateObject("Scripting.Dictionary")
	init
End Sub

Private Sub Module_Terminate()
	set elementCache = nothing
	set packageCache = nothing
End Sub

private sub init()
	if not IsObject(elementCache) then
		set elementCache = CreateObject("Scripting.Dictionary")
	end if
	if not IsObject(packageCache) then
		set packageCache = CreateObject("Scripting.Dictionary")
	end if
end sub
'Group of functions related to information from the model

'returns the fully qualified name for the given item.
'this is the full path of the element divided by dots e.g. "Root.GrandParent.Parent.Item"
function getFullyQualifiedName(item)
	dim fqn, parentfqn
	fqn = ""
	'add the parent part
	parentFQN = getParentFQN(item)
	if len(parentFQN) > 0 then
		fqn = parentFQN & "."
	end	if
	fqn = fqn & getItemName(item)
	getFullyQualifiedName = fqn
end function

'returns the parent object for the given object
function getParentFQN(item)
	dim itemType, parentID, parent, parentFQN, packageID
	parentID = 0
	packageID = 0
	parentFQN = ""
	set parent = nothing
	itemType = TypeName(item)
	select case itemType
		case "IDualElement"
			parentID = item.ParentID
			packageID = item.PackageID
		case "IDualConnector"
			parentID = item.ClientID
		case "IDualAttribute"
			parentID = (item.parentID)
		case "IDualDiagram"
			parentID = item.ParentID
			packageID = item.PackageID
		case "IDualPackage"
			packageID = item.ParentID
	end select
	if parentID > 0 then
		'the item is owned by an element
		'first check if the element is in the cache already
		if elementCache.Exists(parentID) then
			'get the FQN from the cache
			parentFQN = elementCache(parentID)
		else
			'not in the cache, get the element and its FQN
			set parent = Repository.GetElementByID(parentID)
			parentFQN = getFullyQualifiedName(parent)
			'add it to the cache
			elementCache.Add parentID, parentFQN
		end if
	elseif packageID > 0 then
		'the item is owned by a package
		'first check if it is in the cache already
		if packageCache.Exists(packageID) then
			'get the FQN from the cache
			parentFQN = packageCache(packageID)
		else
			'not in the cache
			set parent = Repository.GetPackageByID(packageID)
			parentFQN = getFullyQualifiedName(parent)
			'add it to the cache
			packageCache.Add packageID, parentFQN
		end if
	end if
	getParentFQN = parentFQN
end function

function getItemName(item)
	dim itemName
	itemName = item.Name
	if len(itemName) = 0 then
		itemName = "[Anonymous]"
	end if
	getItemName = itemName
end function

'gets the attributes by the id's returned by the given query
function getAttributesByQuery(sqlQuery)
	dim xmlResult
	xmlResult = Repository.SQLQuery(sqlQuery)
	dim attributeIDs
	attributeIDs = convertQueryResultToArray(xmlResult)
	dim attributes 
	set attributes = CreateObject("System.Collections.ArrayList")
	dim attributeID
	dim attribute as EA.Attribute
	for each attributeID in attributeIDs
		if attributeID > 0 then
			set attribute = Repository.GetAttributeByID(attributeID)
			if not attribute is nothing then
				attributes.Add(attribute)
			end if
		end if
	next
	set getAttributesByQuery = attributes
end function

function getConnectorsFromQuery(sqlQuery)
	dim xmlResult
	xmlResult = Repository.SQLQuery(sqlQuery)
	dim connectorIDs
	connectorIDs = convertQueryResultToArray(xmlResult)
	dim connectors 
	set connectors = CreateObject("System.Collections.ArrayList")
	dim connectorID
	dim connector as EA.Connector
	for each connectorID in connectorIDs
		if connectorID > 0 then
			set connector = Repository.GetConnectorByID(connectorID)
			if not connector is nothing then
				connectors.Add(connector)
			end if
		end if
	next
	set getConnectorsFromQuery = connectors
end function



function selectObjectFromQualifiedName(rootPackage,rootElement, qualifiedName, seperator)
	dim foundObject
	set foundObject = nothing
	'devide qualified name into parts
	dim parts
	parts = Split(qualifiedName,seperator)
	if ubound(parts) >= 0 then
		dim rootPart
		dim rootOK, rootName
		rootOK = false
		dim hasElement
		hasElement = false
		rootPart = parts(0)
		'check if we have a root element
		if not rootElement is nothing then
			rootName = rootElement.Name
			hasElement = true
		else
			rootName = rootPackage.Name
		end if
		'check the rootname
		if lcase(rootName) = lcase(rootPart) then
			rootOK = true
		end if
		if rootOK then
			if ubound(parts) > 0 then
				dim childPart
				childPart = parts(1)
				'check attributes if the childpart is the last part
				'debug
				'Session.Output "Searching root = " & rootName & " child = " & childPart & " qualifiedName = " & qualifiedName
				if hasElement AND ubound(parts) = 1 then
					set foundObject = getAttributeByName(rootElement, childPart)
					'if no attribute found we try to find an operation
					if foundObject is nothing then
						set foundObject = getOperationByName(rootElement, childPart)
					end if
				end if
				
				'nothing found we go deeper
				if foundObject is nothing then
					dim subElement as EA.Element
					dim subPackage as EA.Package
					set subPackage  = nothing
					if hasElement then
						set subElement = getSubElementByName(rootElement,childPart)
					else
						set subElement = getSubElementByName(rootPackage,childPart)
						if subElement is nothing then
							set subPackage = getSubPackageByName(rootPackage, childPart)
						end if
					end if
					'go deeper
					dim substring
					substring = mid(qualifiedName, len(rootPart) + len(seperator) +1)
					if not subElement is nothing then
						set foundObject = selectObjectFromQualifiedName(nothing,subElement, substring, seperator)
					elseif not subPackage is nothing then
						set foundObject = selectObjectFromQualifiedName(subPackage,nothing, substring, seperator)
					end if
				end if
			else
				'only one part is given, return root
				if hasElement then
					set foundObject = rootElement
				else
					set foundObject = rootPackage
				end if
			end if
		end if
	end if
	set selectObjectFromQualifiedName = foundObject
end function

function getAttributeByName(element, attributeName)
	set getAttributeByName = nothing
	if not element is nothing then
		dim attribute as EA.Attribute
		for each attribute in element.Attributes
			if lcase(attribute.Name) = lcase(attributeName) then
				set getAttributeByName = attribute
				exit for
			end if
		next
	end if
end function

function getOperationByName(element, operationName)
	set getOperationByName = nothing
	if not element is nothing then
		dim operation as EA.Method
		for each operation in element.Methods
			if lcase(operation.Name) = lcase(operationName) then
				set getOperationByName = operation
				exit for
			end if
		next
	end if
end function

function getSubElementByName(owner, elementName)
	set getSubElementByName = nothing
	if not owner is nothing then
		dim subElement as EA.Element
		for each subElement in owner.Elements
			if lcase(subElement.Name) = lcase(elementName) then
				set getSubElementByName = subElement
				exit for
			end if
		next
	end if
end function

function getSubPackageByName(package, packageName)
	set getSubPackageByName = nothing
	if not package is nothing then
		dim subPackage as EA.Package
		for each subPackage in package.Packages
			if lcase(subPackage.Name) = lcase(packageName) then
				set getSubPackageByName = subPackage
				exit for
			end if
		next
	end if
end function


'returns an ArrayList with the elements accordin tot he ObjectID's in the given query
'function getElementsFromQuery(sqlQuery)
'	dim elements 
'	set elements = Repository.GetElementSet(sqlQuery,2)
'	dim result
'	set result = CreateObject("System.Collections.ArrayList")
'	dim element
'	for each element in elements
'		result.Add Element
'	next
'	set getElementsFromQuery = result
'end function
'
''returns a comma separated string with the package id's the given package and all subpackages recusively
'function getPackageTreeIDString(package)
'	dim packageTree
'	set packageTree = getPackageTree(package)
'	getPackageTreeIDString = makePackageIDString(packageTree)
'end function
'
''returns an ArrayList of the given package and all its subpackages recursively
'function getPackageTree(package)
'	dim packageList
'	set packageList = CreateObject("System.Collections.ArrayList")
'	addPackagesToList package, packageList
'	set getPackageTree = packageList
'end function
'
''add the given package and all subPackges to the list (recursively
'function addPackagesToList(package, packageList)
'	dim subPackage as EA.Package
'	'add the package itself
'	packageList.Add package
'	'add subpackages
'	for each subPackage in package.Packages
'		addPackagesToList subPackage, packageList
'	next
'end function
'
''make an id string out of the package ID of the given packages
'function makePackageIDString(packages)
'	dim package as EA.Package
'	dim idString
'	idString = ""
'	dim addComma 
'	addComma = false
'	for each package in packages
'		if addComma then
'			idString = idString & ","
'		else
'			addComma = true
'		end if
'		idString = idString & package.PackageID
'	next 
'	'if there are no packages then we return "0"
'	if packages.Count = 0 then
'		idString = "0"
'	end if
'	'return idString
'	makePackageIDString = idString
'end function

'Returns the value of the tagged value with the given name (case insensitive)
'If there is no tagged value with the given name, an empty string is returned
'This function can be used with anything that can have tagged values
function getTaggedValueValue(owner, taggedValueName)
	dim taggedValue as EA.TaggedValue
	getTaggedValueValue = ""
	for each taggedValue in owner.TaggedValues
		if lcase(taggedValueName) = lcase(taggedValue.Name) then
			getTaggedValueValue = taggedValue.Value
			exit for
		end if
	next
end function

function getOrCreateTaggedValue(owner,taggedValueName)
	'Initialize
	set getOrCreateTaggedValue = nothing
	'check if tagged value exists
	for each taggedValue in owner.TaggedValues
		if lcase(taggedValueName) = lcase(taggedValue.Name) then
			set getOrCreateTaggedValue = taggedValue
			exit function
		end if
	next
	'if not found create new one
	set getOrCreateTaggedValue = owner.TaggedValues.addNew(taggedValueName,"")
end function

function getRootPackage(selectedElement)
	'initialize
	set getRootPackage = nothing
	dim selectedPackage as EA.Package
	if selectedElement is nothing then
		set selectedPackage = Repository.GetTreeSelectedPackage
	else
		if selectedElement.ObjectType = otElement _
		  OR selectedElement.ObjectType = otDiagram then
			set selectedPackage = Repository.GetPackageByID(selectedElement.PackageID)
		elseif selectedElement.ObjectType = otPackage then
			set selectedPackage = selectedElement
		end if
	end if
	if not selectedPackage is nothing then
		if selectedPackage.ParentID = 0 then
			set getRootPackage = selectedPackage
		else
			dim parentPackage
			set parentPackage = Repository.GetPackageByID(selectedPackage.ParentID)
			set getRootPackage = getRootPackage(parentPackage)
		end if 
	end if
end function
'
' END: ../Framework/Utils/ModelInfo.vbs
' #######################

'
' #######################
' BEGIN: ../Framework/Utils/SQL.vbs

'[path=\Framework\Utils]
'[group=Utils]
'Author: Geert Bellekens
'Date: 2015-12-07

'returns the SQL wildcard depending on the type of repository
function getWC()
	if Repository.RepositoryType = "JET" then
		getWC = "*"
	else
		getWC = "%"
	end if
end function

'escapes a literal string so it can be inserted using sql
function escapeSQLString(inputString)
	'replace the single quotes with two single quotes for all db types
	escapeSQLString = replace(inputString, "'","''")
	'dbspecifics
	select case Repository.RepositoryType
		case "POSTGRES"
			' replace backslash "\" by double backslash "\\"
			escapeSQLString = replace(escapeSQLString,"\","\\")
		case "JET"
			'replace pipe character | by '& chr(124) &'
			escapeSQLString = replace(escapeSQLString,"|", "'& chr(124) &'")
	end select
end function
'
' END: ../Framework/Utils/SQL.vbs
' #######################

'
' #######################
' BEGIN: ../Framework/Utils/TextFile.vbs

'[path=\Framework\Utils]
'[group=Utils]
'Author: Geert Bellekens
'Date: 2015-12-07
' Already inlined !INC Utils.Include


Class TextFile
	Private m_FullPath
	Private m_Contents
	Private m_Folder
	Private m_FileName

	Private Sub Class_Initialize
	  set m_Folder = Nothing
	  m_FileName = ""
	  m_Contents = ""
	End Sub
	
	' FullPath property.
	Public Property Get FullPath
	  FullPath = me.Folder.FullPath & "\" & me.FileName
	End Property	
	public Property Let FullPath(value)
	  dim startBackslash
	  startBackslash = InstrRev(value, "\", -1, 1)
	  dim folderPath
	  folderPath = left(value, startBackslash -1) 'get everything before the last "\"
	  if ucase(folderPath) <> ucase(me.Folder.FullPath) then
		'make new folder object to avoid side effects on the folder object
		me.Folder = New FileSystemFolder
		me.Folder.FullPath = left(value, startBackslash -1) 'get everything before the last "\"
	  end if
	  me.FileName = mid(value, startBackslash + 1) 'get everything after the last "."
	end Property
		
	' Contents property.
	Public Property Get Contents
	  Contents = m_Contents
	End Property
	Public Property Let Contents(value)
	  m_Contents = value
	End Property
	
	' FileName property.
	Public Property Get FileName
	  FileName = m_FileName
	End Property
	Public Property Let FileName(value)
	  m_FileName = value
	End Property
	' FileNameWithoutExtension property.
	Public Property Get FileNameWithoutExtension
	  dim startExtension
          FileNameWithoutExtension = FileName
	  startExtension = InstrRev(me.FileName, ".", -1, 1)
          if startExtension <> 0 then
	    FileNameWithoutExtension = left(me.FileName, startExtension -1) 'get everything before the last "."
          end if
	End Property
	' Extension property.
	Public Property Get Extension
	  dim startExtension
	  startExtension = InstrRev(me.FileName, ".", -1, 1)
	  Extension = mid(me.FileName, startExtension + 1) 'get everything after the last "."
	End Property
	
	' Folder property.
	Public Property Get Folder
	  if m_Folder is nothing then
		set m_Folder = new FileSystemFolder
	  end if
	  set Folder = m_Folder
	End Property
	Public Property Let Folder(value)
	  set m_Folder = value
	End Property
	
	'save the file
	sub Save
		Dim fso, MyFile
		Set fso = CreateObject("Scripting.FileSystemObject")
		'invalid characters cause errors, ignore them
		On Error Resume Next
		'first make sure the directory exists
		me.Folder.Save
		If Err.Number <> 0 Then
			Session.Output "ERROR: " &  Err.Description
			Err.Clear
			exit sub
		End If

		'then create file
		Set MyFile = fso.CreateTextFile(me.FullPath, True)
		If Err.Number <> 0 Then
			Session.Output "ERROR: " &  Err.Description
			Err.Clear
			exit sub
		End If
		On Error Goto 0

		MyFile.Write(Contents)
		MyFile.close
		
	end sub
	
	'delete the file
	sub Delete
		Dim fso
		Set fso = CreateObject("Scripting.FileSystemObject")
		if fso.FileExists(me.FullPath) then
			fso.DeleteFile me.FullPath
		end if
	end sub
	'let the user select a file from the file system
	public function UserSelect(initialDir,filter)
		dim selectedFileName
		selectedFileName = ChooseFile(initialDir,filter)
		'check if anything was selected
		if len(selectedFileName) > 0 then
			me.FullPath = selectedFileName
			UserSelect = true
			me.LoadContents
		else
			UserSelect = false
		end if
	end function
	'load the contents of the file from the file system
	public function loadContents()
		Dim fso
		dim fsoFile
		dim ts
		Set fso = CreateObject("Scripting.FileSystemObject")
		if fso.FileExists(me.FullPath) then
			set fsoFile = fso.GetFile(me.FullPath)
			set ts = fsoFile.OpenAsTextStream(ForReading, TristateUseDefault)
			me.Contents = ts.ReadAll
                        ts.Close
		end if
	end function
	'appends the given string to the end of the textfile
	public function append(contentToAppend)
		dim fso
		Set fso = CreateObject("Scripting.FileSystemObject")
		dim fsoFile
		if not fso.FileExists(me.FullPath) then
			'create as new file
			me.Contents = contentToAppend
			me.save
		else
			'then append to the file
			Set fsoFile = fso.OpenTextFile(me.FullPath, ForAppending,TristateUseDefault)
			fsoFile.Write contentToAppend
			fsoFile.Close
		end if
	end function
	
end class

'Static functions
function writeFile(filename, contents)
	dim file
	set file = New TextFile
	file.FullPath = filename
	file.Contents = contents
	file.Save
end function
'
' END: ../Framework/Utils/TextFile.vbs
' #######################

'
' #######################
' BEGIN: ../Framework/Utils/XML.vbs

'[path=\Framework\Utils]
'[group=Utils]
!INC Local Scripts.EAConstants-VBScript

'Author: Geert Bellekens
'Date: 2015-12-07

'converts the query results from Repository.SQLQuery from xml format to a two dimensional array of strings
Public Function convertQueryResultToArray(xmlQueryResult)
    Dim arrayCreated
    Dim i 
    i = 0
    Dim j 
    j = 0
    Dim result()
    Dim xDoc 
    Set xDoc = CreateObject( "MSXML2.DOMDocument" )
    'load the resultset in the xml document
    If xDoc.LoadXML(xmlQueryResult) Then        
		'select the rows
		Dim rowList
		Set rowList = xDoc.SelectNodes("//Row")

		Dim rowNode 
		Dim fieldNode
		arrayCreated = False
		'loop rows and find fields
		For Each rowNode In rowList
			j = 0
			If (rowNode.HasChildNodes) Then
				'redim array (only once)
				If Not arrayCreated Then
					ReDim result(rowList.Length, rowNode.ChildNodes.Length)
					arrayCreated = True
				End If
				For Each fieldNode In rowNode.ChildNodes
					'write f
					result(i, j) = fieldNode.Text
					j = j + 1
				Next
			End If
			i = i + 1
		Next
	end if
    convertQueryResultToArray = result
End Function

public Function sanitizeXMLString(invalidString)
	Dim tmp, i 
	tmp = invalidString
	'first replace ampersand
	tmp = Replace(tmp, chr(38), "&amp;") 
	'then the other special characters
	For i = 160 to 255
		tmp = Replace(tmp, chr(i), "&#" & i & ";")
	Next
	'and then the special characters
	tmp = Replace(tmp, chr(34), "&quot;")
	tmp = Replace(tmp, chr(39), "&apos;")
	tmp = Replace(tmp, chr(60), "&lt;")
	tmp = Replace(tmp, chr(62), "&gt;")
	'tmp = Replace(tmp, chr(32), "&nbsp;")
	sanitizeXMLString = tmp
end function

'sub test
'	dim test
'	test = sanitizeXMLString("invali""d'strï¿½iï¿½ng<&>")
'	Session.Output "sanitized: " & test
'end sub
'test

'returns the string encoded int he base64 zipped contents of the given xml string
public function decodeBase64zippedXML(xmlString,nodeName)
		Dim xDoc 
		Set xDoc = CreateObject( "MSXML2.DOMDocument" )
		decodeBase64zippedXML = ""
		'get the stereotype
		'load the resultset in the xml document
		If xDoc.LoadXML(xmlString) Then    
			dim contentsNode 
			set contentsNode = xDoc.SelectSingleNode("//" & nodeName)
			if not contentsNode is nothing then
				dim contentsDecoded
				contentsDecoded = contentsNode.nodeTypedValue
				'save as temp zip file
				dim tempZipFile
				set tempZipFile = new BinaryFile
				tempZipFile.FullPath = replace(getTempFilename, ".tmp",".zip")
				tempZipFile.Contents = contentsDecoded
				tempZipFile.Save
				'unzip 
				dim tempFolderPath
				tempfolderPath = unzip(tempZipFile.FullPath)
				'get the text file 
				dim tempFolder
				set tempFolder = new FileSystemFolder
				tempFolder.FullPath = tempfolderPath
				dim contentsFile
				For each contentsFile in tempfolder.TextFiles
					decodeBase64zippedXML = contentsFile.Contents
					'there should be only one file
					exit for
				next
				'delete the temp folder and temp file name
				tempfolder.Delete
				tempZipFile.Delete
			end if
		end if
end function
'
' END: ../Framework/Utils/XML.vbs
' #######################

'
' #######################
' BEGIN: ../Framework/Utils/Util.vbs

!INC Local Scripts.EAConstants-VBScript
'[path=\Framework\Utils]
'[group=Utils]
'


' Script Name: Util
' Author: Geert Bellekens
' Purpose: serves as library for other scripts
' Date: 28/09/2015
'

'definee the atrias Red color to be used by different scripts
dim atriasRed
atriasRed =  RGB(153, 20, 37)

' Synchronises the names of the selected objects or BPMN Activities with their classifier/called activity ref.
' Will also set the composite diagram to that of the classifier/ActivityRef in order to facilitate click-through
function synchronizeElement (element)
	'first check if this is an object or an action
	if not element is Nothing then
		if (element.Type = "Object" OR element.Type = "Action") _
		AND element.ClassifierID > 0 then
			dim classifier
			set classifier = Repository.GetElementByID(element.ClassifierID)
			if not classifier is nothing AND classifier.name <> element.name then
				element.Name = classifier.Name
				element.Stereotype = classifier.Stereotype
				element.Update
				Repository.AdviseElementChange(element.ElementID)
			end if
			'elements of type object should also point to the composite diagram of the classifier
			if element.Type = "Object" then
				dim compositeDiagram
				set compositeDiagram = classifier.CompositeDiagram
				if not compositeDiagram is nothing then
					setCompositeDiagram element, compositeDiagram
				end if
			end if
		elseif element.Type = "Activity" AND element.Stereotype = "Activity" then
			'BPMN activities that call another BPMN activity need to get the same name and same composite diagram
			dim calledActivityTV as EA.TaggedValue
			set calledActivityTV = element.TaggedValues.GetByName("isACalledActivity")
			dim referenceActivityTV as EA.TaggedValue
			set referenceActivityTV = element.TaggedValues.GetByName("calledActivityRef")
			if not calledActivityTV is nothing and not referenceActivityTV is nothing then
				'only do something when the Activity is types a CalledActivity
				'Session.Output "calledActivityTV.Value : " & calledActivityTV.Value 
				'Session.Output "referenceActivityTV.Value :" & referenceActivityTV.Value
				if calledActivityTV.Value = "true" then
					dim calledActivity as EA.Element
					set calledActivity = Repository.GetElementByGuid(referenceActivityTV.Value)
					if not calledActivity is nothing then
						'set name to that of the called activity
						element.Name = calledActivity.Name
						element.Update
						'Set composite diagram to that of the called activity
						setCompositeDiagram element, calledActivity.CompositeDiagram
					end if
				end if
			end if
		end if
	end if
end function



'set the given diagram as composite diagram for this element
function setCompositeDiagram (element, diagram)
	if not diagram is nothing then
		'Tell EA this element is composite
		dim objectQuery
		objectQuery = "update t_object set NType = 8 where Object_ID = " & element.ElementID
		Repository.Execute objectQuery
		if element.Type = "Object" then
			'Tell EA which diagram is the composite diagram
			dim xrefQuery
			xrefquery = "insert into t_xref (XrefID, Name, Type, Visibility, Partition, Client, Supplier) values ('"&CreateGuid&"', 'DefaultDiagram', 'element property', 'Public', '0', '"& element.ElementGUID & "', '"& diagram.DiagramGUID &"')"
			Repository.Execute xrefquery
		elseif element.Type = "Activity" then
			'for activities we need to update PDATA1 with the diagramID
			dim updatequery
			updatequery = "update t_object set PDATA1 = "& diagram.DiagramID & " where Object_ID = " & element.ElementID
			Repository.Execute updatequery
		end if
	end if
end function

' Returns a unique Guid on every call. Removes any cruft.
Function CreateGuid()
    CreateGuid = Left(CreateObject("Scriptlet.TypeLib").Guid,38)
End Function


'make an action into a calling activity
function makeCallingActivity(action, activity)
	action.Type = "Activity"
	action.ClassfierID = 0
	action.Stereotype = "Activity"
	action.Update
	action.SynchTaggedValues "BPMN2.0","Activity"
	action.TaggedValues.Refresh
	'first copy the tagged values values
	copyTaggedValuesValues activity, action
	'set tagged values correctly
	dim calledActivityTV as EA.TaggedValue
	set calledActivityTV = action.TaggedValues.GetByName("isACalledActivity")
	calledActivityTV.Value = "true"
	calledActivityTV.Update
	dim referenceActivityTV as EA.TaggedValue
	set referenceActivityTV = action.TaggedValues.GetByName("calledActivityRef")
	referenceActivityTV.Value = activity.ElementGUID
	referenceActivityTV.Update
	action.TaggedValues.Refresh()
end function

'copies values of the tagged values of the source to the values of the corresponding tagged values at the target
function copyTaggedValuesValues (source, target)
	dim taggedValue as EA.TaggedValue
	for each taggedValue in source.TaggedValues
		dim targetTaggedValue as EA.TaggedValue
		set targetTaggedValue = target.TaggedValues.GetByName(taggedValue.Name)
		if not targetTaggedValue is nothing then
			targetTaggedValue.Value = taggedValue.Value
			targetTaggedValue.Update
		end if
	next
end function

'copies the tagged values from the source to the target
function copyTaggedValues(source, target)
	dim sourceTag as EA.TaggedValue
	dim targetTag as EA.TaggedValue
	for each sourceTag in source.TaggedValues
		set targetTag = nothing
		'first try to find target tag
		dim tag as EA.TaggedValue
		for each tag in target.TaggedValues
			if tag.Name = sourceTag.Name then
				set targetTag = tag
				exit for
			end if
		next
		'if not found then create new
		if targetTag is nothing then
			set targetTag = target.TaggedValues.AddNew(sourceTag.Name,"TaggedValue")
		end if
		'set value
		if not targetTag is nothing then
			targetTag.Value = sourceTag.Value
			targetTag.Notes = sourceTag.Notes
			targetTag.Update
			target.Update
		end if
	next
end function

'copies the tagged values from the source to the target
function copyAllTaggedValues(source, target)
	dim sourceTag as EA.TaggedValue
	dim targetTag as EA.TaggedValue
	for each sourceTag in source.TaggedValues
		set targetTag = nothing
		'first try to find target tag, only use if empty
		dim tag as EA.TaggedValue
		for each tag in target.TaggedValues
			if tag.Name = sourceTag.Name _
			 AND len(tag.Value) = 0 then
				set targetTag = tag
				exit for
			end if
		next
		'if not found then create new
		if targetTag is nothing then
			set targetTag = target.TaggedValues.AddNew(sourceTag.Name,"TaggedValue")
		end if
		'set value
		if not targetTag is nothing then
			targetTag.Value = sourceTag.Value
			targetTag.Notes = sourceTag.Notes
			targetTag.Update
			target.Update
		end if
	next
end function

function setFontOnDiagramObject(diagramObject, font, size )
	dim styleParts
	styleParts = Split (diagramObject.Style , ";") 
	dim i
	dim stylepart
	dim fontpart 
	fontpart = "font=" & font
	dim fontSet
	fontSet = false
	dim sizePart
	sizePart = "fontsz=" & size * 10
	dim sizeSet
	sizeSet = false
	for i = 0 to Ubound(styleParts) -1
		stylepart = styleParts(i)
		if Instr(stylepart,"font=") > 0 then
			styleParts(i) = fontpart
			fontSet = true
		elseif Instr(stylepart,"fontsz=") > 0 then
			styleParts(i) = sizePart
			sizeSet = true
		end if
	next
	diagramObject.Style = join(styleParts,";")
	if not fontSet then
		diagramObject.Style =  diagramObject.Style & fontpart & ";"
	end if
	if not sizeSet then
		diagramObject.Style =  diagramObject.Style & sizePart & ";"
	end if
end function

'returns an ArrayList with the elements accordin tot he ObjectID's in the given query
function getElementsFromQuery(sqlQuery)
	dim elements 
	set elements = Repository.GetElementSet(sqlQuery,2)
	dim result
	set result = CreateObject("System.Collections.ArrayList")
	dim element
	for each element in elements
		result.Add Element
	next
	set getElementsFromQuery = result
end function


'returns a dictionary of all elements in the query with their name as key, and the element as value.
'for elements with the same name only one will be returned
function getElementDictionaryFromQuery(sqlQuery)
	dim elements 
	set elements = Repository.GetElementSet(sqlQuery,2)
	dim result
	set result = CreateObject("Scripting.Dictionary")
	dim element
	for each element in elements
		if not result.Exists(element.Name) then
		result.Add element.Name, element
		end if
	next
	set getElementDictionaryFromQuery = result
end function

'get the package id string of the currently selected package tree
function getCurrentPackageTreeIDString()
	'initialize at "0"
	getCurrentPackageTreeIDString = "0"
	dim packageTree
	dim currentPackage as EA.Package
	'get selected package
	set currentPackage = Repository.GetTreeSelectedPackage()
	getCurrentPackageTreeIDString = getPackageTreeIDString(currentPackage)
end function

'get the package id string of the given package tree
function getPackageTreeIDString(package)
	dim allPackageTreeIDs 
	set allPackageTreeIDs = CreateObject("System.Collections.ArrayList")
	dim parentPackageIDs
	set parentPackageIDs = CreateObject("System.Collections.ArrayList")
	if not package is nothing then
		parentPackageIDs.Add package.PackageID
	end if
	'get the actual package ids
	getPackageTreeIDsFast allPackageTreeIDs, parentPackageIDs
	'return
	getPackageTreeIDString = Join(allPackageTreeIDs.ToArray,",")
end function

function getPackageTreeIDsFast(allPackageTreeIDs, parentPackageIDs)
	if parentPackageIDs.Count = 0 then
		if allPackageTreeIDs.Count = 0 then
			'make sure there is at least a 0 in the allPackageTreeIDs
			allPackageTreeIDs.Add "0"
		end if
		'then exit
		exit function
	end if
	'add the parent package ids
	allPackageTreeIDs.AddRange(parentPackageIDs)
	'get the child package IDs
	dim sqlGetPackageIDs
	sqlGetPackageIDs = "select p.Package_ID from t_package p where p.Parent_ID in (" & Join(parentPackageIDs.ToArray, ",") & ")"
	dim queryResult
	set queryResult = getVerticalArrayListFromQuery(sqlGetPackageIDs)
	if queryResult.Count > 0 then
		dim childPackageIDs
		set childPackageIDs = queryResult(0)
		'call recursive function with child package id's
		getPackageTreeIDsFast allPackageTreeIDs, childPackageIDs
	end if
end function

'returns an ArrayList of the given package and all its subpackages recursively
function getPackageTree(package)
	dim packageList
	set packageList = CreateObject("System.Collections.ArrayList")
	addPackagesToList package, packageList
	set getPackageTree = packageList
end function

'add the given package and all subPackges to the list (recursively
function addPackagesToList(package, packageList)
	dim subPackage as EA.Package
	'add the package itself
	packageList.Add package
	'add subpackages
	for each subPackage in package.Packages
		addPackagesToList subPackage, packageList
	next
end function

'make an id string out of the package ID of the given packages
function makePackageIDString(packages)
	dim package as EA.Package
	dim idString
	idString = ""
	dim addComma 
	addComma = false
	for each package in packages
		if addComma then
			idString = idString & ","
		else
			addComma = true
		end if
		idString = idString & package.PackageID
	next 
	'if there are no packages then we return "0"
	if idString = "" then
		idString = "0"
	end if
	'return idString
	makePackageIDString = idString
end function

'make an id string out of the ID's of the given elements
function makeIDString(elements)
	dim element as EA.Element
	dim idString
	idString = ""
	dim addComma 
	addComma = false
	for each element in elements
		if addComma then
			idString = idString & ","
		else
			addComma = true
		end if
		idString = idString & element.ElementID
	next 
	'if there are no elements then we return "0"
	if idString = "" then
		idString = "0"
	end if
	'return idString
	makeIDString = idString
end function

'returns the elements in an ArrayList of the given type from the given diagram
function getElementsFromDiagram(diagram, elementType)
	dim selectedElements
	set selectedElements = CreateObject("System.Collections.ArrayList")
	dim diagramObject as EA.DiagramObject
	dim element as EA.Element
	for each diagramObject in diagram.DiagramObjects
		set element = Repository.GetElementByID(diagramObject.ElementID)
		if element.Type = elementType then
			selectedElements.Add element
		end if
	next
	'return selected Elements
	set getElementsFromDiagram = selectedElements
end function

'returns the diagram objects in an ArrayList for elements of the given type from the given diagram
function getDiagramObjects(diagram, elementType)
	dim selectedElements
	set selectedElements = CreateObject("System.Collections.ArrayList")
	dim diagramObject as EA.DiagramObject
	dim element as EA.Element
	for each diagramObject in diagram.DiagramObjects
		set element = Repository.GetElementByID(diagramObject.ElementID)
		if element.Type = elementType then
			selectedElements.Add diagramObject
		end if
	next
	'return selected Elements
	set getDiagramObjects = selectedElements
end function

'returns the elements in an ArrayList of the given type from the given diagram
'the boundary element should be passed as a DiagramObject
function getElementsFromDiagramInBoundary(diagram, elementType,boundary)
	'dim boundary as EA.DiagramObject
	dim selectedElements
	set selectedElements = CreateObject("System.Collections.ArrayList")
	dim diagramObject as EA.DiagramObject
	dim element as EA.Element
	for each diagramObject in diagram.DiagramObjects
		if (diagramObject.left >= boundary.left and _
			diagramObject.left =< boundary.right and _
			diagramObject.top =< boundary.top and _
			diagramObject.top >= boundary.bottom) then
			'get the element and check the type
			set element = Repository.GetElementByID(diagramObject.ElementID)
			if element.Type = elementType then
				selectedElements.Add element
			end if
		end if
	next
	'return selected Elements
	set getElementsFromDiagramInBoundary = selectedElements
end function

function getWC()
	if Repository.RepositoryType = "JET" then
		getWC = "*"
	else
		getWC = "%"
	end if
end function


function addElementToDiagram(element, diagram, y, x)
	dim diagramObject as EA.DiagramObject
	dim positionString
	'determine height and width
	dim width 
	dim height
	dim elementType
	dim setVPartition 
	setVPartition = false
	elementType = element.Type
	select case elementType       
		case "Event"
			width = 30
			height = 30
		case "Object"
			width = 40
			height = 25
		case "Activity"
			width = 110
			height = 60
		case "ActivityPartition"
			width = 190
			height = 60
			setVPartition = true
		case "Package"
			width = 75
			height = 90
		case else
			'default width and height	
			width = 75
			height = 50
	end select
	'to make sure all elements are vertically aligned we subtract half of the width of the x
	x = x - width/2
	'set the position of the diagramObject
	positionString =  "l=" & x & ";r=" & x + width & ";t=" & y & ";b=" & y + height & ";"
	Session.Output "positionString voor element "& element.Name & " : " &  positionString
	set diagramObject = diagram.DiagramObjects.AddNew( positionString, "" )
	diagramObject.ElementID = element.ElementID
	if setVPartition then
		diagramObject.Style = "VPartition=1"
	end if
	diagramObject.Update
	diagram.DiagramObjects.Refresh
	set addElementToDiagram = diagramObject
end function

'gets the content of the linked document in the given format (TXT, RTF or EA)
function getLinkedDocumentContent(element, format)
	dim linkedDocumentRTF
	dim linkedDocumentEA
	dim linkedDocumentPlainText
	linkedDocumentRTF = element.GetLinkedDocument()
	if format = "RTF" then
		getLinkedDocumentContent = linkedDocumentRTF
	else
		linkedDocumentEA = Repository.GetFieldFromFormat("RTF",linkedDocumentRTF)
		if format = "EA" then
			getLinkedDocumentContent = linkedDocumentEA
		else
			linkedDocumentPlainText = Repository.GetFormatFromField("TXT",linkedDocumentEA)
			getLinkedDocumentContent = linkedDocumentPlainText
		end if
	end if
end function

'returns the currently logged in user
'if security is not enabled then the logged in user is defaulted to me
function getUserLogin()
	'get the currently logged in user
	Dim userLogin
	if Repository.IsSecurityEnabled then
		userLogin = Repository.GetCurrentLoginUser(false)
	else
		userLogin = "SYSTEMAT-TCC\BellekensG"
	end if
	getUserLogin = userLogin
end function	

function getArrayFromQuery(sqlQuery)
	dim xmlResult
	xmlResult = Repository.SQLQuery(sqlQuery)
	getArrayFromQuery = convertQueryResultToArray(xmlResult)
end function

'converts the query results from Repository.SQLQuery from xml format to a two dimensional array of strings
Public Function convertQueryResultToArray(xmlQueryResult)
    Dim arrayCreated
    Dim i 
    i = 0
    Dim j 
    j = 0
    Dim result()
    Dim xDoc 
    Set xDoc = CreateObject( "MSXML2.DOMDocument" )
    'load the resultset in the xml document
    If xDoc.LoadXML(xmlQueryResult) Then        
		'select the rows
		Dim rowList
		Set rowList = xDoc.SelectNodes("//Row")

		Dim rowNode 
		Dim fieldNode
		arrayCreated = False
		'loop rows and find fields
		For Each rowNode In rowList
			j = 0
			If (rowNode.HasChildNodes) Then
				'redim array (only once)
				If Not arrayCreated Then
					ReDim result(rowList.Length, rowNode.ChildNodes.Length)
					arrayCreated = True
				End If
				For Each fieldNode In rowNode.ChildNodes
					'write f
					result(i, j) = fieldNode.Text
					j = j + 1
				Next
			End If
			i = i + 1
		Next
		'make sure the array has a dimension even is we don't have any results
		if not arrayCreated then
			ReDim result(0, 0)
		end if
	end if
    convertQueryResultToArray = result
End Function

function getArrayListFromQuery(sqlQuery)
	dim xmlResult
	xmlResult = Repository.SQLQuery(sqlQuery)
	set getArrayListFromQuery = convertQueryResultToArrayList(xmlResult)
end function

Function convertQueryResultToArrayList(xmlQueryResult)
    Dim result
	set result = CreateObject("System.Collections.ArrayList")
    Dim xDoc 
    Set xDoc = CreateObject( "MSXML2.DOMDocument" )
    'load the resultset in the xml document
    If xDoc.LoadXML(xmlQueryResult) Then        
		'select the rows
		Dim rowList
		Set rowList = xDoc.SelectNodes("//Row")
		Dim rowNode 
		Dim fieldNode
		'loop rows and find fields
		For Each rowNode In rowList
			dim rowArrayList
			set rowArrayList = CreateObject("System.Collections.ArrayList")
			'loop the field nodes
			For Each fieldNode In rowNode.ChildNodes
				'add the contents
				rowArrayList.Add fieldNode.Text
			Next
			'add the row the the general list
			result.Add rowArrayList
		Next
	end if
    set convertQueryResultToArrayList = result
end function

function getVerticalArrayListFromQuery(sqlQuery)
	dim xmlResult
	xmlResult = Repository.SQLQuery(sqlQuery)
	set getVerticalArrayListFromQuery = convertQueryResultToVerticalArrayList(xmlResult)
end function

Function convertQueryResultToVerticalArrayList(xmlQueryResult)
    Dim result
	set result = CreateObject("System.Collections.ArrayList")
    Dim xDoc 
    Set xDoc = CreateObject( "MSXML2.DOMDocument" )
    'load the resultset in the xml document
    If xDoc.LoadXML(xmlQueryResult) Then        
		'select the rows
		Dim rowList
		Set rowList = xDoc.SelectNodes("//Row")
		Dim rowNode 
		Dim fieldNode
		dim firstRow
		firstRow = true
		'loop rows and find fields
		For Each rowNode In rowList
			if firstRow then
				For Each fieldNode In rowNode.ChildNodes
					'add an arraylist for each column
					result.Add CreateObject("System.Collections.ArrayList")
				next
			end if
			'loop the field nodes
			dim i
			i = 0
			For Each fieldNode In rowNode.ChildNodes
				'add the contents to the correct column arraylist
				result(i).Add fieldNode.Text
				i = i + 1
			Next
		Next
	end if
    set convertQueryResultToVerticalArrayList = result
end function

'let the user select a package
function selectPackage()
	'start from the selected package in the project browser
	dim constructpickerString
	constructpickerString = "IncludedTypes=Package"
	dim treeselectedPackage as EA.Package
	set treeselectedPackage = Repository.GetTreeSelectedPackage()
	if not treeselectedPackage is nothing then
		constructpickerString = constructpickerString &	";Selection=" & treeselectedPackage.PackageGUID
	end if
	dim packageElementID 		
	packageElementID = Repository.InvokeConstructPicker(constructpickerString) 
	if packageElementID > 0 then
		dim packageElement as EA.Element
		set packageElement = Repository.GetElementByID(packageElementID)
		dim package as EA.Package
		set package = Repository.GetPackageByGuid(packageElement.ElementGUID)
	else
		set package = nothing
	end if 
	set selectPackage = package
end function

function getConnectorsFromQuery(sqlQuery)
	dim xmlResult
	xmlResult = Repository.SQLQuery(sqlQuery)
	dim connectorIDs
	connectorIDs = convertQueryResultToArray(xmlResult)
	dim connectors 
	set connectors = CreateObject("System.Collections.ArrayList")
	dim connectorID
	dim connector as EA.Connector
	for each connectorID in connectorIDs
		if connectorID > 0 then
			set connector = Repository.GetConnectorByID(connectorID)
			if not connector is nothing then
				connectors.Add(connector)
			end if
		end if
	next
	set getConnectorsFromQuery = connectors
end function

function getDiagramsFromQuery(sqlQuery)
	dim xmlResult
	xmlResult = Repository.SQLQuery(sqlQuery)
	dim diagramIDs
	diagramIDs = convertQueryResultToArray(xmlResult)
	dim diagrams 
	set diagrams = CreateObject("System.Collections.ArrayList")
	dim diagramID
	dim diagram as EA.Diagram
	for each diagramID in diagramIDs
		if diagramID > 0 then
			set diagram = Repository.GetdiagramByID(diagramID)
			if not diagram is nothing then
				diagrams.Add(diagram)
			end if
		end if
	next
	set getDiagramsFromQuery = diagrams
end function

function getAttributesFromQuery(sqlQuery)
	dim xmlResult
	xmlResult = Repository.SQLQuery(sqlQuery)
	dim attributeIDs
	attributeIDs = convertQueryResultToArray(xmlResult)
	dim attributes 
	set attributes = CreateObject("System.Collections.ArrayList")
	dim attributeID
	dim attribute as EA.Attribute
	for each attributeID in attributeIDs
		if attributeID > 0 then
			set attribute = Repository.GetAttributeByID(attributeID)
			if not attribute is nothing then
				attributes.Add(attribute)
			end if
		end if
	next
	set getattributesFromQuery = attributes
end function

function getPackagesFromQuery(sqlQuery)
	dim xmlResult
	xmlResult = Repository.SQLQuery(sqlQuery)
	dim packageIDs
	packageIDs = convertQueryResultToArray(xmlResult)
	dim packages 
	set packages = CreateObject("System.Collections.ArrayList")
	dim packageID
	dim package as EA.Package
	for each packageID in packageIDs
		if packageID > 0 then
			set package = Repository.GetPackageByID(packageID)
			if not package is nothing then
				packages.Add(package)
			end if
		end if
	next
	set getPackagesFromQuery = packages
end function

'get the description from the given notes 
'that is the text between <NL> and </NL> or <FR> and </FR>
function getTagContent(notes, tag)
	if tag = "" then
		getTagContent = notes
	else
		getTagContent = ""
		dim startTagPosition
		dim endTagPosition
		startTagPosition = InStr(notes,"&lt;" & tag & "&gt;")
		endTagPosition = InStr(notes,"&lt;/" & tag & "&gt;")
		'Session.Output "notes: " & notes & " startTagPosition: " & startTagPosition & " endTagPosition: " &endTagPosition
		if startTagPosition > 0 and endTagPosition > startTagPosition then
			dim startContent
			startContent = startTagPosition + len(tag) + 8
			dim length 
			length = endTagPosition - startContent
			getTagContent = mid(notes, startContent, length)
		end if
	end if 
end function

'Returns the value of the tagged value with the given name (case insensitive)
'If there is no tagged value with the given name, an empty string is returned
'This function can be used with anything that can have tagged values
function getTaggedValueValue(owner, taggedValueName)
	dim taggedValue as EA.TaggedValue
	getTaggedValueValue = ""
	for each taggedValue in owner.TaggedValues
		if lcase(taggedValueName) = lcase(taggedValue.Name) then
			if taggedValue.Value = "<memo>" then
				'memo field, return the notes
				getTaggedValueValue = taggedValue.Notes
			else
				'normal field
				getTaggedValueValue = taggedValue.Value
			end if
			exit for
		end if
	next
end function

function getExistingOrNewTaggedValue(owner, tagname)
	dim taggedValue as EA.TaggedValue
	dim returnTag as EA.TaggedValue
	set returnTag = nothing
	'check if a tag with that name alrady exists
	for each taggedValue in owner.TaggedValues
		if taggedValue.Name = tagName then
			set returnTag = taggedValue
			exit for
		end if
	next
	'create new one if not found
	if returnTag is nothing then
		set returnTag = owner.TaggedValues.AddNew(tagname,"")
	end if
	'return
	set getExistingOrNewTaggedValue = returnTag
end function

function isRequireUserLockEnabled()
	dim reqUserLockToEdit
	'default is false
	reqUserLockToEdit = false
	'check if security is enabled
	if Repository.IsSecurityEnabled then
		dim getReqUserLockSQL
		getReqUserLockSQL =	"select sc.Value from t_secpolicies sc " & _
							"where sc.Property = 'RequireLock' "
		dim xmlQueryResult
		xmlQueryResult = Repository.SQLQuery(getReqUserLockSQL)
		dim reqUserLockResults
		reqUserLockResults = convertQueryResultToArray(xmlQueryResult)
		if Ubound(reqUserLockResults) > 0 then
			if reqUserLockResults(0,0) = "1" then
				reqUserLockToEdit = true
			end if
		end if
	end if
	isRequireUserLockEnabled = reqUserLockToEdit
end function

function copyDiagram(diagram, targetOwner)
	dim copiedDiagram as EA.Diagram
	'initialize at nothing
	set copiedDiagram = nothing
	'get the owner package
	dim ownerPackage as EA.Package
	set ownerPackage = Repository.GetPackageByID(diagram.PackageID)
	'check if we need to lock the package to clone it
	if isRequireUserLockEnabled() then
		dim ownerOfOwnerPackage as EA.Package
		if ownerPackage.ParentID > 0 then
			set ownerOfOwnerPackage = Repository.GetPackageByID(ownerPackage.ParentID)
			if not ownerOfOwnerPackage.ApplyUserLock() then
				'tell the user we couldn't do it and then exit the function
				msgbox "Could not lock package " &  ownerPackage.Name & " in order to copy the diagram " & diagram.Name,vbError,"Could not lock Package"
				exit function
			end if
		end if
	end if
	'then actually clone the owner package
	dim clonedPackage as EA.Package
	set clonedPackage = ownerPackage.Clone()
'	if isRequireUserLockEnabled() then
'		clonedPackage.ApplyUserLockRecursive true,true,true
'	end if
	'then get the diagram corresponding to the diagram to copy
	set copiedDiagram = getCorrespondingDiagram(clonedPackage,diagram)
	'set the owner of the copied diagram
	if targetOwner.ObjectType = otElement then
		copiedDiagram.ParentID = targetOwner.ElementID
	else
		copiedDiagram.PackageID = targetOwner.PackageID
	end if
	'save the update to the owner
	copiedDiagram.Update
	'delete the cloned package
	deletePackage(clonedPackage)
	'return the copied diagram
	set copyDiagram = copiedDiagram
end function

function deletePackage(package)
	if package.ParentID > 0 then
		'get parent package
		dim parentPackage as EA.Package
		set parentPackage = Repository.GetPackageByID(package.ParentID )
		dim i
		'delete the pacakge
		for i = parentPackage.Packages.Count -1 to 0 step -1
			dim currentPackage as EA.Package
			set currentPackage = parentPackage.Packages(i)
			if currentPackage.PackageID = package.PackageID then
				parentPackage.Packages.DeleteAt i,false
				exit for
			end if
		next
	end if
end function

function getCorrespondingDiagram(clonedPackage,diagram)
	dim correspondingDiagram as EA.Diagram
	dim candidateDiagrams
	dim getCandidateDiagramsSQL
	dim packageIDs
	packageIDs = getPackageTreeIDString(clonedPackage)
	getCandidateDiagramsSQL = 	"select d.Diagram_ID from t_diagram d " & _
								" where d.name = '" & diagram.Name & "' " & _
								" and d.Package_ID in (" & packageIDs& ") "
	set candidateDiagrams = getDiagramsFromQuery(getCandidateDiagramsSQL)
	'if there is only one candidate then that is the one we take
	if candidateDiagrams.Count = 1 then
		set correspondingDiagram = candidateDiagrams(0)
	end if
	'if there are multiple candidates then we have to filter them
	'first create a dictionary with the diagrams and their owner
	dim candidateDiagramsDictionary
	set candidateDiagramsDictionary = CreateObject("Scripting.Dictionary")
	dim currentDiagram
	for each currentDiagram in candidateDiagrams
		'add the diagram and its owner to the dictionary
		candidateDiagramsDictionary.Add currentDiagram, getOwner(diagram)
	next
	dim currentowner
	set currentOwner = nothing
	'filter the diagrams until we have only one diagram left
	set correspondingDiagram = filterDiagrams(candidateDiagramsDictionary,diagram, clonedPackage, currentOwner)
	'return the diagram
	set getCorrespondingDiagram = correspondingDiagram
end function

function filterDiagrams(candidateDiagramsDictionary,diagram, clonedPackage, currentOwner)
	dim filteredDiagrams
	dim filteredDiagram as EA.Diagram
	'initialize at nothing
	set filteredDiagram = nothing
	set filteredDiagrams = CreateObject("Scripting.Dictionary")
	if currentOwner is nothing then
		set currentOwner = getOwner(diagram)
	end if
	'compare the diagrams and their owner with the current owner
	dim candidateDiagram as EA.Diagram
	dim candidateOwner
	for each candidateDiagram in candidateDiagramsDictionary.Keys
		set candidateOwner = candidateDiagramsDictionary(candidateDiagram)
		if candidateOwner.Name = currentOwner.Name then
			'add the diagram to the new list 
			filteredDiagrams.Add candidateDiagram, getOwner(candidateOwner)
		end if
	next
	'check the number if we have reached he level of the cloned package, or if there is only one diagram left
	if filteredDiagrams.Count = 1 _
	OR currentOwner.ObjectType = otPackage AND currentOwner.ParentID = clonedPackage.PackageID then
		'return the first one
		set filteredDiagram = filteredDiagrams.Keys()(0)
	else
		'go one level deeper to filter the diagrams
		set currentOwner = getOwner(currentOwner)
		set filteredDiagram = filterDiagrams(filteredDiagrams,diagram, clonedPackage, currentOwner)
	end if
	'return filtered diagram
	set filterDiagrams = filteredDiagram
end function

function getOwner(item)
	dim owner
	select case item.ObjectType
		case otElement,otDiagram,otPackage
			'if it has an element as owner then we return the element
			if item.ParentID > 0 then
				set owner = Repository.GetElementByID(item.ParentID)
			else
				if item.ObjectType <> otPackage then
					'else we return the package (not for packages because then we have a root package that doesn't have an owner)
					set owner = Repository.GetPackageByID(item.PackageID)
				end if
			end if
	'TODO: add other cases such as attributes and operations
	end select
	'return owner
	set getOwner = owner
end function

Function lpad(strInput, length, character)
  lpad = Right(String(length, character) & strInput, length)
end function

function makeArrayFromArrayLists(arrayLists)
	dim returnArray()
	'get the dimensions
	dim x
	dim y
	x = arrayLists.Count
	dim row
	y = 0
	'get the largest row for y
	for each row in arrayLists
		if y < row.Count then
			y = row.Count
		end if
	next
	'redim the array to the correct dimensions
	redim returnArray(x-1,y-1)
	dim i,j
	i = 0
	dim field
	for each row in arrayLists
		'reset j
		j = 0
		for each field in row
			if IsObject(field) then
				set returnArray(i,j) = field
			else
				returnArray(i,j) = field
			end if
			j = j + 1
		next
		i = i + 1
	next
	'return the array
	makeArrayFromArrayLists = returnArray
end function

' EA uses a lot of key=value pairs in different types of fields (such as StyleEx etc.)
' each of them separated by a ";"
' this function will search for the value of the key and return the value if it is present in the given search string
function getValueForkey(searchString, key)
	dim returnValue
	returnValue = ""
	dim keyValuePairDictionary
	set keyValuePairDictionary = getKeyValuePairs(searchString)
	if keyValuePairDictionary.Exists(key) then
		returnValue = keyValuePairDictionary(key)
	end if
	'return the value
	getValueForkey = returnValue
end function

' EA uses a lot of key=value pairs in different types of fields (such as StyleEx etc.)
' each of them separated by a ";"
' returns a dictionary witht the key value pairs
function getKeyValuePairs(keyValueString)
	dim keyValuePairDictionary
	Set keyValuePairDictionary = CreateObject("Scripting.Dictionary")
	dim keyValuePairs
	'first split in keyvalue pairs using ";"
	keyValuePairs = split(keyValueString,";")
	'then loop the key value pairs
	dim keyValuePairString
	for each keyValuePairString in keyValuePairs
		'and split them usign "=" as delimiter
		dim keyValuePair
		if instr(keyValuePairString,"=") > 0 then
			keyValuePair = split(keyValuePairString,"=")
			if UBound(keyValuePair) = 1 then
				'set the value, don't care about duplicate keys
				keyValuePairDictionary(keyValuePair(0)) = keyValuePair(1)
			end if
		end if
	next
	'return
	set getKeyValuePairs = keyValuePairDictionary
end function

'merge two array together. First a1, then a2
Function mergeArrays(a1, a2)
  ReDim aTmp(Ubound(a1, 1) + Ubound(a2,1) + 1, UBound(a1, 2) )
  Dim i, j, k
  For i = 0 To UBound(a1, 1)
      For j = 0 To UBound(aTmp, 2)
          aTmp(i, j) = a1(i, j)
      Next
  Next
  For k = 0 To UBound(a2, 1)
      For j = 0 To UBound(aTmp, 2)
          aTmp(i + k, j) = a2(k, j)
      Next
  Next
  mergeArrays = aTmp
End Function

'returns a new dictionary that is sorted using it's key
function getSortedDictionary(dictionary)
	dim sortedDictionary
	set sortedDictionary = CreateObject("Scripting.Dictionary")
	'get a list of key and sort the keys
	dim sortedKeys
	set sortedKeys = CreateObject("System.Collections.ArrayList")
	dim key
	for each key in dictionary.Keys
		sortedKeys.Add key
	next
	'sort the keys
	sortedKeys.Sort
	'fill the dictionary with the values of the original dictionary using the sorted keys
	for each key in sortedKeys
		sortedDictionary.Add key, dictionary(key)
	next
	'return
	set getSortedDictionary = sortedDictionary
end function

'returns the version control ID's used in this model
function getVersionControlIDs()
	set getVersionControlIDs = getVersionControlIDsForPackages("")
end function

'returns the version control ID's used in by the packages in the package id list (comma separated)
function getVersionControlIDsForPackages(packageIDs)
	dim sqlGetVersionControlIDs
	sqlGetVersionControlIDs = "select distinct substring(p.PackageFlags,charindex('VCCFG=',p.PackageFlags) + len('VCCFG=')                                               " & _
						" ,charindex(';', p.PackageFlags,charindex('VCCFG=',p.PackageFlags)) - (charindex('VCCFG=',p.PackageFlags) + len('VCCFG='))) as TFSConfig  " & _
						" from t_package p where p.PackageFlags like '%VCCFG=%'                                                                                    "
	if len(packageIDs) > 0 then
		sqlGetVersionControlIDs = sqlGetVersionControlIDs & " and p.Package_ID in (" & packageIDs & ")" 
	end if
	'add order by
	sqlGetVersionControlIDs = sqlGetVersionControlIDs & " order by 1 "
	dim tempResult
	set tempResult = getVerticalArrayListFromQuery(sqlGetVersionControlIDs)
	dim versionControlIDs 
	if tempResult.Count > 0 then
		'get the first "column" arraylist
		set versionControlIDs = tempResult(0)
	else
		set versionControlIDs = CreateObject("System.Collections.ArrayList")
	end if
	'return
	set getVersionControlIDsForPackages = versionControlIDs
end function
'
' END: ../Framework/Utils/Util.vbs
' #######################

'
' #######################
' BEGIN: ../Framework/Utils/EA Enums.vbs

'[path=\Framework\Utils]
'[group=Utils]


!INC Local Scripts.EAConstants-VBScript

'
' Script Name: EA Enums
' Author: Geert Bellekens
' Purpose: Contains the enums missed by EAConstants-VBScript
' Date: 2017-10-20
'
' Version Control Status
' From http://www.sparxsystems.com/enterprise_architect_user_guide/13.5/automation/package_2.html
const csUncontrolled 				= 0
const csCheckedIn 					= 1
const csCheckedOutToThisUser 		= 2
const csReadOnlyVersion 			= 3
const csCheckedOutToAnotherUser 	= 4
const csOfflineCheckedIn 			= 5
const csCheckedOutOfflineByUser 	= 6
const csCheckedOutOfflineByOther 	= 7
const csDeleted 					= 8
'
' END: ../Framework/Utils/EA Enums.vbs
' #######################


'Author: Geert Bellekens
'Date: 2015-12-07
'
' END: ../Framework/Utils/Include.vbs
' #######################


'Author: Geert Bellekens
'Date: 2015-12-07

'for some reason all scripts in the database have this value in the column scriptCategory
Const scriptCategory = "605A62F7-BCD0-4845-A8D0-7DC45B4D2E3F"

Class Script
        Private MAX_SQL_SIZE

        Private m_Name
        Private m_Code
        Private m_Group
        Private m_Id
        Private m_GUID

        Private Sub Class_Initialize
          ' These files fail
          '   74556 ./Projects/Project A/Reports and exports/FIS - BP - Matrix export.vbs
          '  293828 ./Framework/Tools/Script Management/LoadScriptsBootstrap.vbs
          MAX_SQL_SIZE = 75000
          m_Name = ""
          m_Code = ""
          m_Id = ""
          set m_Group = Nothing
        End Sub

        ' Name property.
        Public Property Get Name
          Name = m_Name
        End Property
        Public Property Let Name(value)
          m_Name = value
        End Property

        ' Code property.
        Public Property Get Code
          Code = m_Code
        End Property
        Public Property Let Code(value)
          m_Code = value
        End Property

        ' Id property.
        Public Property Get Id
          Id = m_Id
        End Property
        Public Property Let Id(value)
          m_Id = value
        End Property

        ' GUID property.
        Public Property Get GUID
          GUID = m_GUID
        End Property
        Public Property Let GUID(value)
          m_GUID = value
        End Property

        ' Path property.
        Public Property Get Path
          Path = getPathFromCode
          if len(Path) < 1 then
                Path = "\" & me.Group.Name
          end if
        End Property

        ' Group property.
        Public Property Get Group
          set Group = m_Group
        End Property
        Public Property Let Group(value)
          set m_Group = value
          'add the script to the group
           m_Group.Scripts.Add me
        End Property

        ' GroupNameInCode property
        Public Property Get GroupInNameCode
          GroupInNameCode = getGroupFromCode()
        End Property

        ' GroupTypeFromCode property
        Public Property Get GroupType
                GroupType = getGroupTypeFromCode()
        End Property


        ' Gets all scripts stored in the model
        Public function getAllScripts(allGroups)
                dim resultArray, scriptGroup,row,queryResult
                set scriptGroup = new scriptGroup
                set allGroups = scriptGroup.getAllGroups()
                dim allScripts
                set allScripts = CreateObject("System.Collections.ArrayList")
                dim sqlGet
                sqlGet = "select s.ScriptID, s.Notes, s.Script,ps.Script as SCRIPTGROUP, ps.Notes as GROUPNOTES, ps.ScriptID as GroupID, ps.ScriptName as GroupGUID, s.ScriptName as ScriptGUID " & _
                                         " from t_script s " & _
                                         " inner join t_script ps on s.ScriptAuthor = ps.ScriptName " & _
                                         " where s.notes like '<Script Name=" & getWC() & "'"
        queryResult = Repository.SQLQuery(sqlGet)
                resultArray = convertQueryResultToArray(queryResult)
                dim id, notes, code, group, name, groupNotes, groupID, groupGUID, scriptGUID
                dim i
                For i = LBound(resultArray) To UBound(resultArray)
                        id = resultArray(i,0)
                        notes = resultArray(i,1)
                        code = resultArray(i,2)
                        group = resultArray(i,3)
                        groupNotes = resultArray(i,4)
                        groupID = resultArray(i,5)
                        groupGUID = resultArray(i,6)
                        scriptGUID = resultArray(i,7)
                        if len(notes) > 0 then
                                'first get or create the group
                                if allGroups.Exists(groupID) then
                                        set scriptGroup = allGroups(groupID)
                                else
                                        set scriptGroup = new ScriptGroup
                                        scriptGroup.Name = group
                                        scriptGroup.Id = groupID
                                        scriptGroup.GUID = groupGUID
                                        scriptGroup.setGroupTypeFromNotes groupNotes
                                        'add the group to the dictionary
                                        allGroups.Add groupID, scriptGroup
                                end if
                                'then make the script
                                name = getNameFromNotes(notes)
                                dim script
                                set script = New Script
                                script.Id = id
                                script.Name = name
                                script.Code = code
                                script.GUID = scriptGUID
                                'add the group to the script
                                script.Group = scriptGroup
                                'add the script to the list
                                allScripts.Add script
                        end if
                next
                set getAllScripts = allScripts
        End function

        'the notes contain= <Script Name="MyScriptName" Type="Internal" Language="JavaScript"/>
        'so the name is the second part when splitted by double quotes
        private function getNameFromNotes(notes)
                dim parts
                parts = split(notes,"""")
                getNameFromNotes = parts(1)
        end function

        'the path is defined in the code as '[path=\directory\subdirectory]
        private function getPathFromCode()
                getPathFromCode = getKeyValue("path")
        end function
        'the Group is defined in the code as '[group=NameOfTheGroup]
        public function getGroupFromCode()
                getGroupFromCode = getKeyValue("group")
        end function
        ' the Group Type is defined in the code as '[group_type=GroupType]
        ' if not specified then defaults to gtNormal
        private function getGroupTypeFromCode()
                getGroupTypeFromCode = getKeyValue("group_type")
                if getGroupTypeFromCode = "" then
                        getGroupTypeFromCode = gtNormal
                end if
        end function

        'the key-value pair is defined in the code as '[keyName=value]
        public function getKeyValue(keyName)
                dim returnValue
                returnValue = "" 'initialise emtpy
                getKeyValue = returnValue

                dim keyIndicator, startKey, endKey, tempValue, prevCharIndex, prevChar
                keyIndicator = "'[" & keyName & "="
                'Session.Output "DEBUG: getKeyValue: searching for " & keyIndicator
                startKey = instr(me.Code, keyIndicator)
                if startKey = 0 then
                        'no matches found
                        'Session.Output "DEBUG: getKeyValue: no start key found, " & keyIndicator
                        'Session.Output "DEBUG: getKeyValue: in Script " & me.Name
                        'Session.Output "DEBUG: getKeyValue: code=" & me.Code
                        exit function
                end if

                'only allow key/values at the beginning of a line
                prevCharIndex = startKey - 1
                'check at beginning of line, prevCharIndex=0 indicates its the first line of the file
                if prevCharIndex <> 0 then
                        prevChar = mid(me.Code, prevCharindex, 1)
                        if prevChar <> vbLf and prevChar <> vbCr then
                                'key/value not at start of line
                                'Session.Output "DEBUG: getKeyValue: previous char is not new line, '" & Asc(prevChar) & "' at index " & prevCharindex
                                exit function
                        end if
                end if

                endKey = instr(startKey, me.Code, "]")
                if endKey = 0 then
                        'no closing bracket
                        'Session.Output "DEBUG: getKeyValue: no closing bracket ']'"
                        exit function
                end if

                'move startkey to after keyIndicator
                startKey = startKey + len(keyIndicator)
                tempValue = mid(me.code, startKey, endKey - startKey)
                'filter out multiline results in case someone forgot to add the closing "]"
                if instr(tempValue,vbNewLine) <> 0 or instr(tempValue,vbLF) <> 0 then
                        Session.Output "ERROR: " & keyIndicator & " missing closing ] on same line"
                        exit function
                end if
                returnValue = tempValue

                getKeyValue = returnValue
                'Session.Output "DEBUG: getKeyValue: " & keyName & " = " & getKeyValue
        end function

        public function addGroupToCode()
                dim groupFromCode
                groupFromCode = me.getGroupFromCode()
                if not len(groupFromCode) > 0 then
                        'add the group indicator
                        me.Code = "'[group=" & me.Group.Name & "]" & vbNewLine & me.Code
                end if
        end function


        'Insert the script in the database
        public sub Create
                dim sqlInsert
                sqlInsert = "insert into t_script (ScriptCategory, ScriptName, ScriptAuthor, Notes, Script) " & _
                                        " Values ('" & scriptCategory & "','" & me.GUID & "','" & me.Group.GUID & "','<Script Name=""" & me.Name & """ Type=""Internal"" Language=""VBScript""/>','" & escapeSQLString(me.Code) & "')"
                Session.Output "DEBUG: Script.Create Len(sqlInsert)=" & Len(sqlInsert)
                if Len(sqlInsert) < MAX_SQL_SIZE then
                   Repository.Execute sqlInsert
                else
                   Session.Output "ERROR: Unable to create script " & me.Group.Name & "." & me.Name & " due to database limits"
                end if
        end sub

        'update the script in the database
        public sub Update
                dim sqlUpdate
                sqlUpdate = "update t_script set script = '" & escapeSQLString(me.Code) & "', ScriptAuthor = '" & me.Group.GUID & _
                                        "', Notes = '<Script Name=""" & me.Name & """ Type=""Internal"" Language=""VBScript""/>' where ScriptName = '" & me.GUID & "'"
                Session.Output "DEBUG: Script.Update Len(sqlUpdate)=" & Len(sqlUpdate)
                if Len(sqlUpdate) < MAX_SQL_SIZE then
                   Repository.Execute sqlUpdate
                else
                   Session.Output "ERROR: Unable to create script " & me.Group.Name & "." & me.Name & " due to database limits"
                end if
        end sub

end Class
'
' END: ../Framework/Wrappers/Scripting/Script.vbs
' #######################

'
' #######################
' BEGIN: ../Framework/Wrappers/Scripting/ScriptGroup.vbs

'[path=\Framework\Wrappers\Scripting]
'[group=Wrappers]


' Already inlined !INC Utils.Include

'Author: Geert Bellekens
'Date: 2015-12-07
'constants for group type in database
Const gtNormal = "NORMAL", gtProjectBrowser = "PROJBROWSER", gtDiagram = "DIAGRAM", gtWorkflow = "WORKFLOW", _
  gtSearch = "SEARCH", gtModelSearch = "MODELSEARCH", gtContextElement = "CONTEXTELEMENT", _
  gtContextPackage = "CONTEXTPACKAGE", gtContextDiagram = "CONTEXTDIAGRAM", gtContextLink = "CONTEXTLINK"

'for some reason all groups have this value in column scriptCategory
Const scriptGroupCategory = "3955A83E-9E54-4810-8053-FACC68CD4782"

Class ScriptGroup 
	Private m_Id
	Private m_GUID
	Private m_Name
	Private m_GroupType
	Private m_Scripts
	
	Private Sub Class_Initialize
	  m_Id = ""
	  m_Name = ""
	  m_GroupType = ""
	  set m_Scripts = CreateObject("System.Collections.ArrayList")
	End Sub
	
	' Id property.
	Public Property Get Id
	  Id = m_Id
	End Property
	Public Property Let Id(value)
	  m_Id = value
	End Property	
	
	' GUID property.
	Public Property Get GUID
	  GUID = m_GUID
	End Property
	Public Property Let GUID(value)
	  m_GUID = value
	End Property	
	
	' Name property.
	Public Property Get Name
	  Name = m_Name
	End Property
	Public Property Let Name(value)
	  m_Name = value
	End Property

	' GroupType property.
	Public Property Get GroupType
	  GroupType = m_GroupType
	End Property
	Public Property Let GroupType(value)
	  m_GroupType = value
	End Property
	
	' Scripts property.
	Public Property Get Scripts
	  set Scripts = m_Scripts
	End Property
	
	'the notes contain something like <Group Type="NORMAL" Notes=""/>
	'so the group type is the second part when splitted by double quotes
	private function getGroupTypeFromNotes(notes)
		dim parts
		parts = split(notes,"""")
		getGroupTypeFromNotes = parts(1)
		if getGroupTypeFromNotes = "" then
			getGroupTypeFromNotes = gtNormal
		end if
	end function
	
	'sets the GroupType based on the given notes
	public sub setGroupTypeFromNotes(notes)
		GroupType = getGroupTypeFromNotes(notes)
	end sub
	
	'gets a dictionary of all groups without the scripts
	public function getAllGroups()
		dim allGroups, sqlGet
		dim queryResult
		dim resultArray
		set allGroups = CreateObject("Scripting.Dictionary")
		sqlGet = "select s.[ScriptID], s.[ScriptName] AS GroupGUID, s.[Notes], s.[Script] as GroupName " & _
				" from t_script s " & _
				" where s.Notes like '<Group Type=" & getWC() & "'"
		queryResult = Repository.SQLQuery(sqlGet)
		resultArray = convertQueryResultToArray(queryResult)
		dim groupId, groupGUID, groupName, notes, scriptGroup
		dim i
		For i = LBound(resultArray) To UBound(resultArray)
			groupId = resultArray(i,0)
			groupGUID = resultArray(i,1)
			notes = resultArray(i,2) 
			groupName = resultArray(i,3)
			if len(notes) > 0 then
				'first get or create the group
				if not allGroups.Exists(groupID) then
					set scriptGroup = new ScriptGroup
					scriptGroup.Name = groupName
					scriptGroup.Id = groupId
					scriptGroup.GUID = groupGUID
					scriptGroup.setGroupTypeFromNotes notes
					'add the group to the dictionary
					allGroups.Add groupID, scriptGroup
				end if
			end if
		next
		set getAllGroups = allGroups
	end function
	
	'Insert the group in the database
	public sub Create
		dim sqlInsert
		sqlInsert = "insert into t_script (ScriptCategory, ScriptName,Notes, Script) " & _
					" Values ('" & scriptGroupCategory & "','" & me.GUID & "','<Group Type=""" & me.GroupType & """ Notes=""""/>','" & me.Name & "')"
		Repository.Execute sqlInsert
	end sub

	public sub Update
		dim sqlUpdate
		sqlUpdate = "update t_script set Notes = '<Group Type=""" & me.GroupType & """ Notes=""""/>' where ScriptName = '" & me.GUID & "'"
		Repository.Execute sqlUpdate
	end sub

end Class
'
' END: ../Framework/Wrappers/Scripting/ScriptGroup.vbs
' #######################

'
' #######################
' BEGIN: ../Framework/Wrappers/TaggedValues/TaggedValue.vbs

'[path=\Framework\Wrappers\TaggedValues]
'[group=Wrappers]
'Option Explicit

!INC Local Scripts.EAConstants-VBScript

''' ===========================================================================
''' TAGGEDVALUE HELPER
''' ===========================================================================
''' VERSION			: 0.9.6
'''	RELEASE DATE	: 2015-12-10
''' HISTORY			: See History.txt				First release in 2015-12-07
'''
''' DESCRIPTION		: A TaggedValue Helper wrapper, intending to provide access 
'''					  to TaggedValue properties with consistent (orthogonal)  
''' 				  property names. More info far below.
''' 
''' AUTHOR			: Rolf Lampa, RIL Partner AB, rolf.lampa@rilnet.com
'''
''' COPYRIGHT		: (C) Rolf Lampa, 2015. Free to use for commercial projects 
'''				  	  if giving proper attribution to the author and providing 
'''					  this copyright info visible in your code and product 
'''					  documentation, including donation info below.
'''
''' DONATIONS		: If you find the script being useful you may consider 
'''					  making a donation. All amounts amounts. For Paypal 
'''					  donations, use the following url:
'''
''' https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=KJCD6N8M8MRWQ
'''
''' DEPENDENCIES 	: None. The script should work as is inside Enterprise 
'''					  Architect. 
''' TESTED			: Run on Enterprise Architect 12.1 Beta, using the file
'''					  "TaggedValue_Test.vbs" for simple property access
'''
''' ---------------------------------------------------------------------------
'''
''' USAGE: The code below (for example) will provide a "singleton" access to 
'''		   the TaggedValue helper:

Dim m_tagapi 	''' You may want to use this variable directly, the after first 
				''' access to the TagAPI

Public Function TagAPI()
	''' Ensure that the TaggedVaslue helper is created only once.
	if m_tagapi is Nothing then
		Set m_tagapi = New TTaggedValueWrapper
	End If
	Set TagAPI = m_tagapi
End Function

Private Sub Module_Initialize()
	''' Ensure initialization of the variable as to prepare 
	''' for the assigment check in the TagAPI() function
	Set m_tagapi = Nothing
End Sub

Private Sub Module_Terminate()
	''' Call this explicitly to dispose of the object.
	Set m_tagapi = Nothing
End Sub

''' ---------------------------------------------------------------------------
''' EXAMPLE OF USAGE:
'''
'''		Dim tv As EA.TaggedValue
'''		For Each tv in Pkg.Element.TaggedValues
''' 		Session.Output TagAPI.Wrap(tv)				''' Wrap...
''' 		Session.Output TagAPI.Wrap(tv).Value()		''' or Wrap and use directly.
''' 		Session.Output TagAPI.Name()				''' Now use the helper Obj directly
''' 		Session.Output m_tagapi.Notes()				''' Or use the module variable
''' 		Session.Output m_tagapi.FQName()					
''' 		Session.Output m_tagapi.PropertyGUID()					
''' 		Session.Output m_tagapi.ParentName()					
''' 		Session.Output m_tagapi.ParentID()					
''' 		Session.Output m_tagapi.ParentGUID()			
''' 		''' Etc
''' 	Next
''' 
''' 	One can also use a class, and set the wrapper "ByName", then the wrapper
''' 	looks up the TaggedValue, wraps it, and exposes its properties, like so:
'''
'''		For Each elem in Pkg.Elements
'''			If TagApi.TryWrapByName("VBA.FileName", elem)  then
''' 			Session.Output m_tagapi.Name()			
''' 			Session.Output m_tagapi.Notes()			
''' 			Session.Output m_tagapi.PropertyGUID()
''''		End If
'''		Next
'''
'''		''' Or, if assuming that the TV exists:
'''
''' 	S = TagApi.WrapByName("VBA.FileName", elem).Notes()
'''		
''' ---------------------------------------------------------------------------
'''
''' STATISTICS
''' 
''' Simple statistics is supported but can be "disabled" from the code altogether 
''' by using the following Regex Expression:
'''
''' DISABLE all stats code (comment):
''' 	Regex Search:	^(?!'//)(.*?\(\(\$stats\)\).*?$)
'''		Regex Replace:	'//\1
''' ENABLE stats code again (uncomment):
''' 	Regex Search:	^(?='//)'//(.*?\(\(\$stats\)\).*?$)
'''		Regex Replace:	\1

''' ---------------------------------------------------------------------------
''' TODO:
''' - Property IsInterfaceTag() - Check Stereotype to distinguish from regular 
'''   Class
'''
''' ---------------------------------------------------------------------------
''' CLASS MEMEBERS
''' ---------------------------------------------------------------------------
'''
'''		''' Most used properties & functions :
'''
'''     ''' WrapByName: Direct access to properties assuming the TV exists
'''		Public Function WrapByName(aName, ByRef aObj) ''': TTaggedValueWrapper
'''		Public Function TryWrapByName(aName, ByRef aObj) ''': Boolean
'''		Public Function Wrap(ByRef aTaggedValue) ''': TTaggedValueWrapper
'''		Public Property Get Value() ''': String
'''		Public Function TryValue(ByRef S) ''': Boolean
'''		Public Property Get Name()	''': String
'''		Public Property Get Notes()	''': String
'''		Public Sub Update() ''': Void			''' All PropertyTypes reloaded from Repository. Total reinitialization
'''		
'''		'// Statistics control :
'''		
'''		Public Sub StatsPause() ''': Void		''' Collects Duration and HitCounts into ditto "Accumulated"
'''		Public Sub StatsResume() ''': Void		''' Restarts with HitCount=0 (AccumulatedCount continues though)
'''		Public Sub StatsStart() ''': Void		''' Resets all counters and timers
'''		Public Sub StatsStop() ''': Void		''' Keeps all count and time info until next StatsStart()

'''		''' Other useful and orthogonal properties.
'''		''' In case a value isn't actually provided by the underlaying object, 
'''		''' these properties at least provides with a fake value as to allowing 
'''		''' for "type safe" when traversing EA models.
'''		
'''		Public Property Get Detail() ''': String
'''		Public Property Get FQName() ''': String
'''		Public Property Get HasMemo() ''': Boolean
'''		Public Property Get HasNotes()	''': String
'''		Public Property Get HasStats() ''': Boolean
'''		Public Property Get IsAttributeTag() ''': Boolean
'''		Public Property Get IsClassTag() ''': Boolean
'''		Public Property Get IsConnectionTag() ''': Boolean
'''		Public Property Get IsElementTag() ''': Boolean
'''		Public Property Get IsInterfaceTag() ''': Boolean
'''		Public Property Get IsMethodTag() ''': Boolean
'''		Public Property Get IsPackageTag() ''': Boolean
'''		Public Property Get IsRoleTag() ''': Boolean
'''		Public Property Get IsTaggedValue() ''': Boolean
'''		Public Property Get IsValueDefault() ''': Boolean
'''		Public Property Get M_Default()	''': String
'''		Public Property Get M_GlobalDefault()	''': String
'''		Public Property Get M_IsRoleTag() ''': Boolean
'''		Public Property Get M_ParentObject() ''': EA.<Object>
'''		Public Property Get M_Value() ''': String
'''		Public Property Get TvObject() ''': EA.TaggedValue		''' Useful with WrapByName
'''		Public Property Get ParentID() ''': Integer
'''		Public Property Get ParentName() ''': String
'''		Public Property Get ParentObject() ''': EA.<Object>
'''		Public Property Get ParentObjectType() ''': Integer (ot<ObjectType>)
'''		Public Property Get ParentType() ''': String (Kind name)
'''		Public Property Get PropertyGUID() ''': String
'''		Public Property Get PropertyID() ''': String
'''		Public Property Get StatsCount() ''': Integer
'''		Public Property Get StatsCountAcc() ''': Integer
'''		Public Property Get StatsDuration() ''': Time
'''		Public Property Get StatsDurationAcc() ''': Time
'''		Public Property Get StatsHitsPerSecond() ''': Integer
'''		Public Property Get StatsHitsPerSecondAcc() ''': Integer
'''		Public Property Get StatsTimePerHits() ''': Time
'''		Public Property Get StatsTimePerHitsAcc() ''': Integer
'''		Public Property Get StatsWrapCount() ''': Integer
'''		
'''		Private Function ContainsStr(aStr, aChar)
'''		Private Function ExtractPropertyFromRawStr(ByRef aSubjectStr, ByVal aFieldName) ''': Boolean
'''		Private Function GetValueByXmlTagName(ByRef aStr, ByRef aTagName, ByRef OutResult) ''': String, Boolean
'''		Private function PropertyTypeByName(aNameAsKey, ByRef OutProp) ''': PropertyType, Boolean
'''		Private Function QueryRoleTagForElementID(ByRef OutGUID) ''': Boolean
'''		Private Function TryExtractRoleTagStereotypeDefault(ByRef S) ''': String, Boolean
'''		Private Function TryExtractRoleTagValue(ByRef S) ''': Boolean
'''		Private Function TryExtractStereotypeDefault(ByRef s) ''': Boolean		
'''		Private function TryGetPropertyTypeDefault(aNameAsKey, ByRef OutResult) ''': String, Boolean
'''		Private Property Get ConnectionEndForRoleTag()
'''		Private Property Get ConnectorForRoleTag()
'''		Private Property Get IsClient() ''': Boolean
'''		Private Property Get IsSource() ''': Boolean
'''		Private Property Get IsSupplier() ''': Boolean
'''		Private Property Get IsTarget() ''': Boolean
'''		Private Property Get PropertyTypesDefaultDictionary()  ''': Dictionary
'''		Private Property Get PropertyTypesDictionary
'''		Private Property Get PropertyTypesRawDataDictionary() ''': Dictionary
'''		Private Property Get RoleTagConnector()
'''		Private Property Let UseStats(aBool) ''': Void	''' (($stats))
'''		
'''		Private Sub Class_Initialize() ''': Void
'''		Private Sub Class_Terminate() ''': Void
'''		
'''		Private Sub FormatPropertyTypesText(ByRef aSubjectStr)
'''		Private Sub IncStats() ''': Void					''' (($stats))
'''		Private Sub LoadPropertyData()
'''		Private Sub RegisterPropertyTypes() ''': Void
'''		Private Sub RegisterPropertyTypesDefaults() ''': Void
'''		Private Sub RegisterPropertyTypesRawData() ''': Void
'''		Private Sub ResetData() ''': Void
'''		Private Sub ResetStats() ''': Void					''' (($stats))
''' -----------------------------------------------------------------------


''' TAGGEDVALUE TYPES

Public Const EA_TaggedValue 	= 12	''' Classes & Packages
Public Const EA_AttributeTag	= 34	''' Attributes
Public Const EA_MethodTag		= 36	''' Methods
Public Const EA_ConnectorTag	= 38	''' Connectors
Public Const EA_RoleTag			= 41	''' Role/ConnectorEnd

''' MODEL ELEMENTS

Public Const EA_Element 		= 4		''' Class & Interface (see <stereotype>!)
Public Const EA_Class 			= 4		''' -"-
Public Const EA_Interface		= 4		''' -"-
Public Const EA_Package			= 5		''' Package
Public Const EA_Attribute		= 23	''' Attributes
Public Const EA_Method			= 24	''' Methods
Public Const EA_Connector		= 7		''' Connectors
Public Const EA_Role			= 22	''' Role/ConnectorEnd
Public Const EA_ConnectorEnd	= 22	''' Role/ConnectorEnd

Public Const EA_ASSOCIATION_SOURCE = "ASSOCIATION_SOURCE"
Public Const EA_ASSOCIATION_TARGET = "ASSOCIATION_TARGET"

''' ERROR CODES & MESSAGES

Dim err_ElementType : err_ElementType = vbObjectError + 1
Dim err_TaggedValueType : err_TaggedValueType = vbObjectError + 1

Private Const msg_ElementType = "Invalid Element Type!"
Private Const msg_TaggedValueType = "Invalid TaggedValue type!"

''' HELPER CLASS

Class TTaggedValueWrapper
	
	''' The currently wrapped EA.TaggedValue + EA.RoleTag.
	Dim m_tv As EA.TaggedValue
	
	''' EA.RoleTag (special case) introduced for optmization reasons. It is 
	'''	being assigned already at the time of Wrap(tv)
	Dim m_rt As EA.RoleTag
	
	''' The owning EA.Connector (only) for visiting EA.RoleTags.
	Dim m_roletag_connector As EA.Connector
	
	''' Optimized Access, Lazy evaluation in ParentObject (but or course, needs a type cast for usage)
	Dim m_parentobj As EA.Element
	Dim m_parent_typename						'// For chaching purpose.
	Dim m_parent_objecttype
	
	Dim m_objecttype
	
	''' Used by InStr() & Mid() when extracting values from text. Avoids repeated allocs.
	Dim m_startpos
	Dim m_endpos
	
	''' Dictionary for fast RT access of Property OBJECTS
	''' accessed by TaggedValue name
	Dim m_PropertyTypesDictionary
	
	''' Dictionary for fast direct RT access of property Defaults, 
	''' in String format, accessed directly by TaggedValue Name()
	Dim m_PropertyTypesDefaultDictionary
	
	''' Dictionary for storing property data from .Detail property, 
	''' in a prepared format making it easier (faster) to extract any
	''' individual property value from its multiline text content. 
	''' Performance and the utilization of Lazy Evaluation motivates
	''' these extra dictionaries.	
	Dim m_PropertyTypesRawDataDictionary

	''' Used by WrapByName to lookup and wrap a TaggedValue by name
	Dim m_elem As EA.Element

	''' STATS                               ''' Keep the "(($stats))" markers (used for Regex enable/disable)
	
	Dim m_usestats							''' (($stats)) Set to false in production code!
	Dim m_stats_hitcount					''' (($stats)) Counts all essesacc to the properties
	Dim m_stats_hitcount_acc				''' (($stats))
	Dim m_stats_wrapcount					''' (($stats)) Counts all assignments with Wrap method since created
	Dim m_stats_starttime					''' (($stats))
	Dim m_stats_stoptime					''' (($stats))
	Dim m_stats_time_acc					''' (($stats))
	
	''' INITIALIZERS
	
	Private Sub Class_Initialize() ''': Void
		ResetStats()						''' (($stats))
		m_usestats = False					''' (($stats)) Must be set explicitly
		Update()
	End Sub
	
	
	Private Sub Class_Terminate() ''': Void
		ResetData()
		m_usestats = False					''' (($stats)) Must be set explicitly
	End Sub
	
	
	''' [TryWrapByName]
	''' Provide a class, an attribute, a connector etc, and a name for the TaggedValue.
	''' If success (result true) then the properties of the TV is immediately available, 
	''' like so: 
	''' 	If TagHelp.TryWrapByName("<TaggedValueName>", Pkg) then 
	''' 		S = TagHelp.Value() ''' etc
	''' 	End If
	Public Function TryWrapByName(aName, ByRef aObj) ''': Boolean
		Dim was_found
		Dim tv As EA.TaggedValue
		Set m_elem = aObj
		Select Case m_elem.ObjectType
			Case EA_Element
				''' m_elem was already set on entry, so go ahead
				Set tv = m_elem.TaggedValues.GetByName(aName)
			Case EA_Package	
				Dim m_pack As EA.Package
				Set m_pack = aObj
				Set tv = m_pack.Element.TaggedValues.GetByName(aName)
			Case EA_Attribute
				Dim m_attr As EA.Attribute
				Set m_attr = aObj
				Set tv = m_attr.TaggedValues.GetByName(aName)
			Case EA_Method
				Dim m_meth As EA.Method
				Set m_meth = aObj
				Set tv = m_meth.TaggedValues.GetByName(aName)
			Case EA_Connector
				Dim m_conn As EA.Connector
				Set m_conn = aObj
				Set tv = m_conn.TaggedValues.GetByName(aName)
			Case EA_ConnectorEnd
				Dim m_role As EA.ConnectorEnd
				Set m_role = aObj
				Set tv = m_role.TaggedValues.GetByName(aName)
			Case Else
				Err.Raise err_ElementType, msg_ElementType
		End Select
		was_found = Not tv is Nothing
		If was_found then
			TryWrapByName = Not Wrap(tv).TvObject Is Nothing
		Else
			TryWrapByName = False
		End If
	End Function
	
	
	''' [WrapByName]
	''' Use the result (object) directly when you know for certain that the 
	''' named TaggedValue will be found, like so:
	'''	S = TagAPI.TagByName("SomeTagName", elem).Value()      or,
	'''	S = TagAPI.TagByName("CopyrightNotice", elem).Notes()  etc.
	Public Function WrapByName(aName, ByRef aObj) ''': TTaggedValueWrapper
		If TryWrapByName(aName, aObj) then
			Set WrapByName = Me
		Else
			Set WrapByName = Nothing
		End If
	End Function
	
	
	''' [Wrap] 
	''' Assigns the external TaggedValue to the wrapper class 
	''' for use in the internal processing.
	Public Function Wrap(ByRef aTaggedValue) ''': TTaggedValueWrapper
		''' m_tv is most often used, if not a RoleTag arrives (then m_rt instead)
		Set m_tv = aTaggedValue
		m_objecttype = m_tv.ObjectType
		''' Cast if RoleTag, this extra property of RoleTag tyoe can now be both 
		''' tested for ("is Nothing") and used directly by any internal properties.
		If m_objecttype = EA_RoleTag Then
			Set m_rt = m_tv
		Else
			Set m_rt = Nothing
		End If
		
		''' This is TaggedValue.ParentObj.ObjectType
		m_parent_objecttype	= 0
		m_startpos			= 0
		m_endpos			= 0
		''' Used internally as a ' cache', sorts of
		m_parent_typename = ""
		''' Lazy Evaluation in Property Get RoleTagConnector													
		Set m_parentobj = Nothing
		Set m_roletag_connector = Nothing
		
		If m_usestats Then 									''' (($stats))
			m_stats_wrapcount = m_stats_wrapcount + 1		''' (($stats))
		End If												''' (($stats))
		
		''' Return this wrapped object as to provide immediate 
		''' access to the wrapper's functionality, like so:
		'''
		''' 	Set tvapi = New TRILTaggedValueApi
		''' 	S = tvapi.Wrap(aTV).Value(), then
		'''		S = tvapi.Value()							''' Avoid using the wrap function more than once
		
		Set Wrap = Me										''' Returns the wrapper itself.
	End Function
	
	
	''' ----------------------------------------------------------
	''' PUBLIC PROPERTIES
	''' ----------------------------------------------------------
	
	
	''' [Value]
	''' Derives any Default value if the tv Value() is empty. Use TryValue(S) 
	''' if you want to utilize a Boolean reply whether any value  at all was 
	''' returned.
	''' This property was the main reason why this wrapper was designed in 
	''' the first place. It attempts to return Value(), and if not exists, 
	''' it tries to get a Default (from "initial value" in Stereotypes), 
	''' and if no value was found there either it reads from GlobalDefault, 
	'''	which has its default values defined in Repository.PropertyTypes() 
	''' and stored in common table 't_propertytypes'.
	''' If you want "direct values" without any of the below semantics applied, 
	''' call M_Value or M_Default, or M_GlobalDefault directly.
	Public Property Get Value() ''': String
		Dim S
		IncStats()										''' (($stats))
		If TryValue(S) Then
			Value = S
		Else
			Value = ""
		End If
	End Property
	
	
	''' [TryValue]
	''' Se documentation for Property Value(). See also EA's documentation page
	''' on how the value content is to be interpreted (rules which we "hide" and just 
	''' deliver in this wrapper) :
	''' http://sparxsystems.com/enterprise_architect_user_guide/12.1/automation_and_scripting/taggedvalue.html
	Public Function TryValue(ByRef S) ''': String
		IncStats()										''' (($stats))
		S = m_tv.Value
		
		''' SPECIAL CASE (RoleTag)
		If m_objecttype = EA_RoleTag Then
			
			''' EA.RoleTag type: Strip out value before "$ea_notes="
			''' The RoleTag must be processed entirely in this block (thus the ElseIf) 
			''' since it's not typecompatible with the other properties for retriveing
			''' Default values.
			
			If TryExtractRoleTagValue(S) Then
				TryValue = True
			ElseIf TryExtractStereotypeDefault(S) Then
				TryValue = True
			ElseIf TryGetPropertyTypeDefault(m_rt.Tag, S) Then	''' (Params = Name, S)				
				''' OK to use common method also for this (RoleTag) type, since
				''' global Defaults are not store in the (Role) TaggedValue itself,
				''' but in the Repository.PropertyTypes, which are common for all.									
				TryValue = True
			Else
				S = ""
				TryValue = False
			End If
			''' NORMAL CASE(S)
		ElseIf  S = "" Then
			''' Try retrive Default ("Initial value" from Stereotype:
			If TryExtractStereotypeDefault(S) Then			
				TryValue = True
				
			ElseIf TryGetPropertyTypeDefault(m_tv.Name, S) Then
				''' As a Last resort, try Default from t_PropertyTypes if
				''' it (this Global) was not "overrided" in a Stereotype.
				TryValue = True
			Else
				''' Neither a Value nor a Default value was found.
				TryValue = False
				S = ""
			End If
		ElseIf S = "<memo>" Then
			''' If "<memo>" the value shall be retrived from .Notes
			S = m_tv.Notes
			TryValue = True
		Else
			TryValue = True 			''' S already contains the value
		End If
	End Function
	
	
	''' [Name]
	''' Special case RoleTag which stores "Name" in its "Tag" property.
	Public Property Get Name()	''': String
		IncStats()									''' (($stats))
		If m_objecttype = EA_RoleTag Then
			Name = m_rt.Tag()
		Else 
			''' In all other cases; EA_TaggedValue, EA_AttributeTag, EA_MethodTag, EA_ConnectorTag
			Name = m_tv.Name()
		End If
	End Property
	
	
	''' [Notes]
	Public Property Get Notes()	''': String
		IncStats()									''' (($stats))
		If m_objecttype = EA_RoleTag Then
			Notes = ""			''' RoleTags doesn't have any notes (Only ConnectorEnd has)
		Else
			Notes = m_tv.Notes
		End If
	End Property
	
	
	''' [PropertyGUID]
	''' Different property names ("TagGUID" and "PropertyGUID") for different Tag owners
	''' requires type check before accessing the properties without crashing :
	Public Property Get PropertyGUID() ''': String
		Select Case m_objecttype
			Case EA_TaggedValue
				' Direct use of the internal ref 'm_tv'
				PropertyGUID = m_tv.PropertyGUID
			Case EA_AttributeTag	
				Dim at As EA.AttributeTag
				Set at = m_tv
				PropertyGUID = at.TagGUID
			Case EA_MethodTag
				Dim mt As EA.MethodTag
				Set mt = m_tv
				PropertyGUID = mt.TagGUID
			Case EA_ConnectorTag	
				Dim ct As EA.ConnectorTag
				Set ct = m_tv
				PropertyGUID = ct.TagGUID
			Case EA_RoleTag
				''' No property ID exist for RoleTag! But we provide a fake ID anyway. 
				''' In any case the user must check the result when calling GetTaggedValueByID(Id)
				PropertyGUID = m_rt.PropertyGUID
			Case Else
				Err.Raise err_TaggedValueType, msg_TaggedValueType
		End Select				
	End Property
	
	
	''' [PropertyID]
	''' Missing property for Roletag. Returns only a Fake ID (-1, since it doesn't have any 
	''' integer ID at all, only a PropertyGUID), but we still provide a value in order to 
	''' avoid type errors for users which are looping through model info.	
	''' Different Tag owners all have different property names.
	Public Property Get PropertyID() ''': String
	Select Case m_objecttype
		Case EA_TaggedValue
    		' Direct use of the internal ref 'm_tv'
    		PropertyID = m_tv.PropertyID
		Case EA_AttributeTag	
    		Dim at As EA.AttributeTag
    		Set at = m_tv
    		PropertyID = at.TagID
		Case EA_MethodTag
    		Dim mt As EA.MethodTag
    		Set mt = m_tv
    		PropertyID = mt.TagID
		Case EA_ConnectorTag	
    		Dim ct As EA.ConnectorTag
    		Set ct = m_tv
    		PropertyID = ct.TagID
		Case EA_RoleTag
    		''' FAKE VALUE: No property ID exist for RoleTag! But we provide a fake ID anyway. 
    		''' In any case the user must check the result when calling GetTaggedValueByID(Id)
    		PropertyID = -1
		Case Else
    		Err.Raise err_TaggedValueType, msg_TaggedValueType 
	End Select		
	End Property
	
	
	''' [FQName]
	''' Fully expanded Stereotype, like so: "Tool::Stereotype::Name"
	Public Property Get FQName() ''': String
	FQName = m_tv.FQName
	End Property
	
	
	''' [M_Value]
	''' Direct value only, no Default values are returned. If you want
	''' Default values if a value isn't set by the user, then call Value()
	''' instead, since it grants that a Default value is returned if it 
	''' by evaluating, in this order: 
	''' 1. Value() || 2. Default() || 3. GlobalDefault()
	Public Property Get M_Value()	''': String
	Dim S
	IncStats()								''' (($stats))
	If m_objecttype = EA_RoleTag Then
		''' Special Case RoleTag
		S = m_rt.Value()
		If TryExtractRoleTagValue(S) Then
			M_Value = S
		Else
			M_Value = ""
		End If
	Else
		''' Normal tags (= all other Tags but RoleTag)
		S = m_tv.Value()
		If  S = "" Then
			M_Value = ""
		ElseIf S = "<memo>" Then
			''' if <memo>, retrive value from .Notes
			M_Value = m_tv.Notes
		Else
			M_Value = S						'// = S already contain the value
		End If
	End If
	End Property
	
	
	''' [M_Default]
	''' Direct value only. The value is retrieved from Stereotypes' "initial 
	''' value" - if any. If no value is found, an attempt to retrived a default 
	''' value from M_GlobalDefault() value instead. But, such semantics is
	''' performed only in the main Value() property.
	Public Property Get M_Default()	''': String
    	Dim S
    	IncStats()								''' (($stats))
    	If TryExtractStereotypeDefault(S) Then
    		M_Default = S
    	Else
    		M_Default = ""
    	End If
	End Property
	
	
	''' [M_GlobalDefault]
	''' Direct value, retrieved from Repository.PropertyTypes, 
	'''	with no extra manipulation of the value is performed.
	Public Property Get M_GlobalDefault()	''': String
    	Dim S
    	Dim sName
    	
    	IncStats()								''' (($stats))
    	
    	''' Get Name for use with  PropertyTypeByName(Name...) below
    	If m_objecttype = EA_RoleTag Then
    		sName = m_rt.Tag
    	Else
    		sName = m_tv.Name
    	End If			
    	
    	If TryGetPropertyTypeDefault(sName, S) Then
    		M_GlobalDefault = S
    	Else
    		M_GlobalDefault = ""
    	End If
	End Property
	
	
	''' [Detail]
	Public Property Get Detail() ''': String
    	Dim p As EA.PropertyType
    	IncStats()									''' (($stats))
    	If PropertyTypeByName(m_tv.Name, p) Then
    		Detail = p.Detail
    	Else
    		Detail = ""
    	End If
	End Property
	
	
	''' [HasNotes]
	''' RoleTags doesn't have any Notes field.
	''' ConnectorEnds, OTOH hand, stores its Notes field in the 
	''' Connector table as t_connector.SourceRoleNote / DestRoleNote
	Public Property Get HasNotes()	''': String
    	IncStats()								''' (($stats))
    	If m_objecttype = EA_RoleTag Then
    		HasNotes = False
    	Else
    		HasNotes = m_tv.Notes <> ""
    	End If
	End Property
	
	
	''' [HasMemo]
	''' RoleTags doesn't have any Memo field.
	Public Property Get HasMemo() ''': Boolean
    	IncStats()								''' (($stats))
    	If m_objecttype = EA_RoleTag Then
    		HasMemo = False
    	Else
    		HasMemo = m_tv.Value = "<memo>"
    	End If
	End Property
	
	
	''' [IsValueDefault]
	''' Determines whether the Value() property is a "native" value or derived from Default()
	Public Property Get IsValueDefault() ''': Boolean
    	IncStats()								''' (($stats))
    	IsValueDefault = (M_Value = "") And (Value <> "")
	End Property
	
	
	''' [ParentType]
	Public Property Get ParentType() ''': String (Kind name)
    	IncStats()								''' (($stats))
    	If m_parent_typename = "" Then
    		Select Case m_objecttype
    			Case EA_TaggedValue		m_parent_typename = Repository.GetElementByID(  	m_tv.ParentID   ).Type
    			Case EA_AttributeTag	m_parent_typename = "Attribute"
    			Case EA_MethodTag		m_parent_typename = "Operation"
    			Case EA_ConnectorTag	m_parent_typename = Repository.GetConnectorByID(	m_tv.ConnectorID).Type
    			Case EA_RoleTag			m_parent_typename = "ConnectorEnd"
    		End Select
    	End If
    	ParentType = m_parent_typename
	End Property
	
	
	''' [ParentID]
	''' Special case for RoleTag / ConnectorEnd
	Public Property Get ParentID() ''': Integer
    	IncStats()								''' (($stats))
    	Select Case m_objecttype
    		Case EA_TaggedValue
        		' Direct use of the internal ref 'm_tv'
        		ParentID = m_tv.ParentID
    		Case EA_AttributeTag	
        		Dim at As EA.AttributeTag
        		Set at = m_tv
        		ParentID = at.AttributeID
    		Case EA_MethodTag
        		Dim mt As EA.MethodTag
        		Set mt = m_tv
        		ParentID = mt.MethodID
    		Case EA_ConnectorTag	
        		''' Return the Connector's ID
        		Dim ct As EA.ConnectorTag
        		Set ct = m_tv
        		ParentID = ct.ConnectorID
    		Case EA_RoleTag
        		''' RoleTagConnector is an expesive call (SQLQuery) 
        		''' but at least it's cached internally
        		ParentID = RoleTagConnector.ConnectorID
    		Case Else
        		Err.Raise err_TaggedValueType, msg_TaggedValueType '// Indicate error
    	End Select			
	End Property
	
	''' [TvObject]
	''' Publishes the currently wrapped TaggedValue. Be aware of that this native 
	''' TV object is NOT "type safe" due to EA tag's inherent un-orthogonality.
	''' Use IsElemenTag, IsConnectorTag, IsRoleTag etc (via this wrapper) to determine 
	'''	the Tag type before using this property.
	Public Property Get TvObject() ''': EA.TaggedValue
		Set TvObject = m_tv
	End Property

		
	''' [ParentObject]
	Public Property Get ParentObject() ''': EA.<Object>
    	IncStats()								''' (($stats))
    	Set ParentObject = M_ParentObject()		''' M_ = No statistics!
	End Property
	
	
	''' [M_ParentObject]
	''' This prop is mainly for internal use. It will NOT succed to call
	''' (un-orthogonal) properties since it returns the actual model entity (thus
	''' for example a RoleTag's Parent (and ConnectionEnd) will not have a property 
	''' Name(), and so an access violation will be rised if calling it.
	'''
	''' ANYWAY, for exactly the above (un-orthogonality) reason, this wrapper also 
	''' provides with type-check functions as enable a convenient means to avoid calling 
	''' unorthogonal properties (See IsRoleTag, IsClassTag, IsPackageTag, IsMethodTag, 
	''' IsAttributeTag and IsConnectionTag, which can be called after the initial Wrap)	
	Public Property Get M_ParentObject() ''': EA.<Object>
    	If m_parentobj Is Nothing Then
    		Select Case m_objecttype
    			Case EA_TaggedValue
    			' Set = use internal ref
    			Set m_parentobj = Repository.GetElementByID(m_tv.ParentID)
    			''' Too expesive to set ParentObject.ObjectType unless required:
    			''' m_parent_objecttype = [skip]
    			Case EA_AttributeTag	
    			Dim at As EA.AttributeTag
    			Set at = m_tv
    			Set m_parentobj = Repository.GetAttributeByID(at.AttributeID)
    			''' While at it, set also:
    			m_parent_objecttype = EA_Attribute
    			Case EA_MethodTag
    			Dim mt As EA.MethodTag
    			Set mt = m_tv
    			Set m_parentobj = Repository.GetMethodByID(mt.MethodID)
    			''' While at it, set also:
    			m_parent_objecttype = EA_Method
    			Case EA_ConnectorTag	
    			''' Return the Connector's name
    			Dim ct As EA.ConnectorTag
    			Set ct = m_tv
    			Set m_parentobj = Repository.GetConnectorByID(ct.ConnectorID)
    			''' While at it, set also:
    			m_parent_objecttype = EA_Connector
    			Case EA_RoleTag
    			''' EA.ConnectorEnd
    			Set m_parentobj = ConnectionEndForRoleTag()
    			''' While at it, set also:
    			m_parent_objecttype = EA_RoleTag
    			Case Else
    			Err.Raise err_TaggedValueType, msg_TaggedValueType '// Indicate error
    		End Select
    	End If
    	Set M_ParentObject = m_parentobj
	End Property
	
	
	''' [ParentName]
	''' This prop. is a "proof of concept" for testing the un-orthogonality 
	''' hidden in this wrapper concept.
	Public Property Get ParentName() ''': String
    	IncStats()									''' (($stats))
    	Select Case m_objecttype
    		Case EA_RoleTag
    		''' Cast neded for access ConnectorEnd's unique properties
    		Dim p_obj As EA.ConnectorEnd
    		Set p_obj = M_ParentObject
    		ParentName = p_obj.Role
    		Case Else
    		ParentName = M_ParentObject.Name
    	End Select
	End Property
	
	
	''' [ParentObjectType]
	Public Property Get ParentObjectType() ''': Integer (ot<ObjectType>)
    	IncStats()									''' (($stats))
    	If m_parent_objecttype > otNone Then		''' otNone = 0
    		M_ParentObjectType = m_parent_objecttype
    	Else
    		''' From the TaggedValue Type we mosty often know which Type the aprent has.
    		''' Check Type of TaggedValue (from Obj.ObjectType which was set already at Wrap)
    		Select Case m_objecttype	
    			Case EA_TaggedValue
    			
    			' Use internal ref
    			Select Case Repository.GetElementByID(m_tv.ParentID).ObjectType
    				Case EA_Package	
    				m_parent_objecttype  = EA_Package
    				Case EA_Element 
    				m_parent_objecttype = EA_Element
    				Case Else 
    				Err.Raise err_ElementType, msg_ElementType '// Indicate error
    			End Select
    			
    			Case EA_AttributeTag
    			m_parent_objecttype = EA_Attribute
    			Case EA_MethodTag
    			m_parent_objecttype = EA_Method
    			Case EA_ConnectorTag
    			m_parent_objecttype = EA_Connector
    			Case EA_RoleTag
    			m_parent_objecttype = EA_ConnectorEnd
    			Case Else 
    			m_parent_objecttype = otNone
    			Err.Raise err_ElementType, msg_ElementType
    		End Select
    	End If
    	M_ParentObjectType = m_parent_objecttype
	End Property
	
	
	''' [IsAttributeTag]
	Public Property Get IsAttributeTag() ''': Boolean
    	IncStats()								''' (($stats))
    	IsAttributeTag = (m_objecttype = EA_AttributeTag)
	End Property
	
	
	''' [IsMethodTag]
	Public Property Get IsMethodTag() ''': Boolean
    	IncStats()								''' (($stats))
    	IsMethodTag = (m_objecttype = EA_MethodTag)
	End Property
	
	
	''' [IsConnectionTag]
	Public Property Get IsConnectionTag() ''': Boolean
    	IncStats()								''' (($stats))
    	IsConnectionTag = (m_objecttype = EA_ConnectorTag)
	End Property
	
	
	''' [IsRoleTag]
	Public Property Get IsRoleTag() ''': Boolean
    	IncStats()								''' (($stats))
    	IsRoleTag = (m_objecttype = EA_RoleTag)
	End Property
	
	
	Public Property Get M_IsRoleTag() ''': Boolean
    	M_IsRoleTag = (m_objecttype = EA_RoleTag)
	End Property
	
	
	''' [IsTaggedValue]
	Public Property Get IsTaggedValue() ''': Boolean
    	IncStats()								''' (($stats))
    	IsTaggedValue = (m_objecttype = EA_TaggedValue)
	End Property
	
	
	''' [IsClassTag]
	''' Element is same as Interface & Class
	Public Property Get IsClassTag() ''': Boolean
    	IncStats()								''' (($stats))
    	IsClassTag = (m_objecttype = EA_TaggedValue)
	End Property
	
	
	''' Element is same as Interface & Class
	Public Property Get IsElementTag() ''': Boolean
    	IncStats()								''' (($stats))
    	IsElementTag = (m_objecttype = EA_TaggedValue)
	End Property
	
	
	''' Element is same as Interface & Class
	''' TODO: Check stereotype to distinguish from regular Class
	Public Property Get IsInterfaceTag() ''': Boolean
    	IncStats()								''' (($stats))
    	IsInterfaceTag = (m_objecttype = EA_TaggedValue)
	End Property
	
	
	''' [IsPackageTag]
	Public Property Get IsPackageTag() ''': Boolean
    	IncStats()								''' (($stats))
    	IsPackageTag = (m_objecttype = EA_TaggedValue)
	End Property
	
	
	''' ----------								
	''' STATS									
	''' ----------					
				
	
	Public Sub StatsStart() ''': Void
		UseStats = True							''' (($stats))
		ResetStats()							''' (($stats))
		m_stats_starttime = Now()				''' (($stats))
	End Sub
	
	
	Public Sub StatsStop() ''': Void
		UseStats = False						''' (($stats))
		m_stats_stoptime = Now()				''' (($stats))
		m_stats_hitcount_acc = m_stats_hitcount_acc + m_stats_hitcount	''' (($stats))
		m_stats_time_acc = m_stats_time_acc + StatsDuration()				''' (($stats))
	End Sub
	
	
	Public Sub StatsPause() ''': Void
		UseStats = False						''' (($stats))
		m_stats_stoptime = Now()				''' (($stats))
		m_stats_hitcount_acc = m_stats_hitcount_acc + m_stats_hitcount	''' (($stats))
		m_stats_time_acc = m_stats_time_acc + StatsDuration()				''' (($stats))
	End Sub
	
	
	Public Sub StatsResume() ''': Void
		UseStats = True									''' (($stats))
		m_stats_hitcount = 0							''' (($stats))
		m_stats_starttime = Now()						''' (($stats))
	End Sub
	
	
	Public Property Get HasStats() ''': Boolean
    	Dim cnt											''' (($stats))
    	cnt = m_stats_hitcount							''' (($stats))
    	cnt = cnt + m_stats_wrapcount					''' (($stats))
    	cnt = cnt + m_stats_hitcount_acc				''' (($stats))
    	HasStats = cnt > 0								''' (($stats))
	End Property
	
	
	Public Property Get StatsDuration() ''': Time
    	If HasStats Then								''' (($stats))
    		StatsDuration = m_stats_stoptime - m_stats_starttime	''' (($stats))
    	Else											''' (($stats))
    		StatsDuration = 0							''' (($stats))
    	End If											''' (($stats))
	End Property
	
	
	Public Property Get StatsDurationAcc() ''': Time
    	If HasStats Then								''' (($stats))
    		StatsDurationAcc = m_stats_time_acc			''' (($stats))
    	Else											''' (($stats))
    		StatsDurationAcc = 0						''' (($stats))
    	End If											''' (($stats))
	End Property
	
	
	Public Property Get StatsCount() ''': Integer
	   StatsCount = m_stats_hitcount					''' (($stats))
	End Property
	
	
	Public Property Get StatsWrapCount() ''': Integer
    	StatsWrapCount = m_stats_wrapcount				''' (($stats))
	End Property
	
	
	Public Property Get StatsCountAcc() ''': Integer
    	StatsCountAcc = m_stats_hitcount_acc			''' (($stats))
	End Property
	
	
	Public Property Get StatsTimePerHits() ''': Time
    	Dim tmp											''' (($stats))
    	If HasStats And (m_stats_hitcount > 0) Then     ''' (($stats))
    		tmp = (m_stats_stoptime - m_stats_starttime) / m_stats_hitcount	''' (($stats))
    	Else											''' (($stats))
    		tmp = 0										''' (($stats))
    	End If											''' (($stats))
    	StatsTimePerHits = tmp							''' (($stats))
	End Property
	
	
	Public Property Get StatsTimePerHitsAcc() ''': Integer
    	Dim tmp											''' (($stats))
    	If HasStats And (m_stats_hitcount_acc> 0) Then				''' (($stats))
    		tmp = m_stats_time_acc / m_stats_hitcount_acc	''' (($stats))
    	Else											''' (($stats))
    		tmp = 0										''' (($stats))
    	End If											''' (($stats))
    	StatsTimePerHitsAcc = tmp						''' (($stats))
	End Property
	
	
	Public Property Get StatsHitsPerSecond() ''': Integer
    	Dim tmp											''' (($stats))
    	tmp = 0											''' (($stats))
    	If HasStats Then								''' (($stats))
    		tmp = StatsDuration							''' (($stats))
    		If tmp > 0 Then								''' (($stats))
    			tmp = StatsCount / Second(tmp)			''' (($stats))
    		Else										''' (($stats))
    			tmp = 0									''' (($stats))
    		End If										''' (($stats))
    	Else											''' (($stats))
    		tmp = 0										''' (($stats))
    	End If											''' (($stats))
    	StatsHitsPerSecond = tmp						''' (($stats))
	End Property
	
	
	Public Property Get StatsHitsPerSecondAcc() ''': Integer
    	Dim acc_cnt										''' (($stats))
    	Dim acc_dur										''' (($stats))
    	Dim res											''' (($stats))
    	
    	res = 0.0										''' (($stats))
    	acc_dur = StatsDurationAcc()					''' (($stats))
    	If HasStats And (acc_dur > 0) Then				''' (($stats))
    		acc_cnt = StatsCountAcc() 					''' (($stats))
    		On Error Resume Next
    		
    		If Second(acc_dur) > 0 Then					''' (($stats))
    			res = acc_cnt / Second(acc_dur)			''' (($stats))
    		End If										''' (($stats))
    		If Err Then									''' (($stats))
    			'''
    		End If										''' (($stats))
    	End If											''' (($stats))
    	StatsHitsPerSecondAcc = res						''' (($stats))
	End Property
	
	
	''' Private -------------
	
	Private Property Let UseStats(aBool) ''': Void	''' (($stats))
    	m_usestats = aBool								''' (($stats))
	End Property										''' (($stats))
	
	
	''' (($stats))
	Private Sub ResetStats() ''': Void					''' (($stats))
		m_stats_hitcount 		= 0						''' (($stats))
		m_stats_hitcount_acc 	= 0						''' (($stats))
		m_stats_starttime		= 0.0					''' (($stats))
		m_stats_stoptime 		= 0.0					''' (($stats))
		m_stats_time_acc 		= 0.0					''' (($stats))
		m_stats_wrapcount 		= 0						''' (($stats))
	End Sub												''' (($stats))
	
	
	''' (($stats))
	Private Sub IncStats() ''': Void					''' (($stats))
		If m_usestats Then 								''' (($stats))
			m_stats_hitcount = m_stats_hitcount + 1	''' (($stats))
		End If											''' (($stats))
	End Sub												''' (($stats))
	
	
	''' --------------------------
	''' PUBLIC FUNCTIONS
	''' --------------------------
	
	''' [Update]
	''' Updates internal Dictionaries by emptying 
	''' and then re-importing data. 
	''' Called also from Class_Initialize()
	Public Sub Update() ''': Void
		ResetData()
		LoadPropertyData()			
	End Sub
	
	
	''' [ResetData]
	''' Updates internal Dictionaries by emptying them
	''' Called from Update() and Class_Initialize()
	Private Sub ResetData() ''': Void
		m_parent_typename 	= ""
		m_objecttype		= otNone
		m_parent_objecttype	= otNone
		m_startpos			= 0
		m_endpos			= 0
		
		Set m_tv = Nothing
		Set m_rt = Nothing
		Set m_parentobj = Nothing
		Set m_roletag_connector = Nothing
		
		Set m_PropertyTypesDictionary = Nothing
		Set m_PropertyTypesDefaultDictionary = Nothing
		Set m_PropertyTypesRawDataDictionary = Nothing
		
		m_usestats			= False						''' (($stats))
		ResetStats()									''' (($stats))			
	End Sub
	
	
	''' [LoadPropertyData]
	''' Updates internal Dictionaries by re-importing data. 
	''' Called also from Update()  and Class_Initialize()
	Private Sub LoadPropertyData()
		RegisterPropertyTypes()
		RegisterPropertyTypesRawData()
		RegisterPropertyTypesDefaults()		
	End Sub
	
	
	''' --------------------------
	''' INTERNAL PROPERTIES
	''' --------------------------
	
	''' [ConnectionEndForRoleTag]
	''' Returns the ConnectorEnd Object
	''' Accessing a ConnectorEnd/RoleObj from TaggedValues must be done via 
	''' its Connector (since ConnectorEnds are stored in the same table, 
	''' the 't_connector'
	''' Determine which end of the (parent) Connector to read from
	''' Notice that the property RoleTagConnector is cached.
	Private Property Get ConnectionEndForRoleTag()	
    	If m_rt Is Nothing Then
    		Err.Raise err_TaggedValueType, msg_TaggedValueType '// Indicate error
    	ElseIf IsClient Then  	''' = EA_ASSOCIATION_SOURCE
    		Set ConnectionEndForRoleTag = RoleTagConnector.ClientEnd
    	Else				''' = EA_ASSOCIATION_TARGET
    		Set ConnectionEndForRoleTag = RoleTagConnector.SupplierEnd
    	End If
	End Property
	
	
	''' [ConnectorForRoleTag]
	Private Property Get ConnectorForRoleTag()
    	Dim guid
    	If QueryRoleTagForElementID(guid) Then 
    		Set ConnectorForRoleTag = Repository.GetConnectorByGuid(guid)
    	Else
    		Set ConnectorForRoleTag = Nothing
    	End If
	End Property
	
	
	''' Applies only when RoleTag is visitor. 
	''' Raises an error if TaggeValue Visitor is not of the type EA.RoleTag
	''' Only for internal use as to support RoleTags with optimized acceess
	''' to it's owning Connector (because many RoleTag properties are stored
	''' in the owning Connector's t_cmnnector table)
	Private Property Get RoleTagConnector()
    	If m_rt Is Nothing Then
    		Err.Raise err_TaggedValueType, msg_TaggedValueType
    	ElseIf m_roletag_connector Is Nothing Then
    		Set m_roletag_connector = ConnectorForRoleTag()
    	End If
    	Set RoleTagConnector = m_roletag_connector
	End Property
	
	
	''' [PropertyTypesDictionary]
	''' Stores the actual PropertyTypes from Repository.PropertyTypes
	''' for fast access. TaggedValue Name is Key, the TV Object is data
	Private Property Get PropertyTypesDictionary
    	If m_PropertyTypesDictionary Is Nothing Then _
    	Set m_PropertyTypesDictionary = CreateObject("Scripting.Dictionary")
    	Set PropertyTypesDictionary = m_PropertyTypesDictionary
	End Property
	
	
	''' [PropertyTypesDefaultDictionary]
	''' Stores the cached DEFAULT VALUE of each PropertyTypes from the Repository.PropertyTypes
	''' for fast access. TaggedValue Name is Key, the Default Value is data
	Private Property Get PropertyTypesDefaultDictionary()  ''': Dictionary
    	If m_PropertyTypesDefaultDictionary Is Nothing Then _
    	   Set m_PropertyTypesDefaultDictionary = CreateObject("Scripting.Dictionary")
    	Set PropertyTypesDefaultDictionary = m_PropertyTypesDefaultDictionary
	End Property
	
	
	''' [PropertyTypesRawDataDictionary]
	''' Stores the cached RAW TEXT from each PropertyTypes from the Repository.PropertyTypes
	''' for fast access. TaggedValue Name is Key, the raw text is data
	Private Property Get PropertyTypesRawDataDictionary() ''': Dictionary
    	If m_PropertyTypesRawDataDictionary Is Nothing Then
    		Set m_PropertyTypesRawDataDictionary = CreateObject("Scripting.Dictionary")
    	End If
    	Set PropertyTypesRawDataDictionary = m_PropertyTypesRawDataDictionary
	End Property
	
	
	''' [IsSource]
	Private Property Get IsSource() ''': Boolean
    	IsSource = m_rt.BaseClass = EA_ASSOCIATION_SOURCE
	End Property
	
	
	''' [IsClient]
	Private Property Get IsClient() ''': Boolean
	   IsClient = m_rt.BaseClass = EA_ASSOCIATION_SOURCE
	End Property
	
	
	''' [IsTarget]
	Private Property Get IsTarget() ''': Boolean
	   IsTarget = m_rt.BaseClass = EA_ASSOCIATION_TARGET
	End Property
	
	
	''' [IsSupplier]
	Private Property Get IsSupplier() ''': Boolean
	   IsSupplier = m_rt.BaseClass = EA_ASSOCIATION_TARGET
	End Property
	
	
	''' [TryExtractStereotypeDefault]
	''' This level of default retrieves its source data
	''' from the Stereotype Initial value, which will have 
	''' the following format: "...Default:<Value>"
	Private Function TryExtractStereotypeDefault(ByRef s) ''': Boolean		
		''' Special case for RoleTags
		If m_objecttype = EA_RoleTag Then		
			If TryExtractRoleTagStereotypeDefault(s) Then
				TryExtractStereotypeDefault = s <> ""
			Else
				s = ""
				TryExtractStereotypeDefault = False
			End If			
		Else
			Dim tmp
			m_startpos = 0
			tmp = m_tv.Notes()
			
			m_startpos = InStr(1, tmp, "Default:", 1)
			''' If Contains :
			If m_startpos > 0 Then
				m_startpos = m_startpos + 8  ''' = Len("Default:")
				''' Use case-IN-sensitive search and strip out 
				''' the value part to the right of the text "Default:"
				s = Trim(Mid(tmp, m_startpos ))
				TryExtractStereotypeDefault = s <> ""
			Else
				s = ""
				TryExtractStereotypeDefault = False
			End If
		End If
	End Function
	
	
	'''	Getters for RoleTag
	
	
	''' [TryExtractRoleTagValue]
	''' Returns pnly the Value(), if any. Since this is only a "helper" function 
	''' thus it must not control the semantics of values. 
	''' However, it actually returns the string content "$ea_notes=", although the 
	'''	function result returns "False" as to leave to the caller to determine 
	''' whether to display that (control) string or not.
	Private Function TryExtractRoleTagValue(ByRef S) ''': Boolean
		''' ------------------------------------
		''' FUTURE FUNCTIONALITY
		''' If m_rt.HasAttributes() then 
		''' 	m_rt.GetAttribute("$ea_notes")
		''' ------------------------------------
		''' Example-string to examine; "Value$ea_notes=Default: DefaultValue"
		m_startpos = InStr(1, S, "$ea_notes=", 1)
		If m_startpos > 1 Then
			''' Contains 'Value' (which has precedence over 'DefaultValue')
			S = Trim( Mid(S, 1, m_startpos-1) )
			TryExtractRoleTagValue = True
		Else
			TryExtractRoleTagValue = False
		End If
	End Function
	
	
	''' [TryExtractRoleTagStereotypeDefault]
	''' Returns ONLY Default value (from Stereotype) and disregards any Value() or 
	''' GlobalDefault() value. 
	''' Strict "m_startpos = 1" logic will NOT return the default value even if it
	''' exists, if a value is preceeding it. Think about that.
	''' 
	''' In this case we only want a default value from here if - and only if - no 
	''' value is present in front of the "$ea_notes=" control string. The reason for 
	''' this is that the user has selected a another value than the 
	''' default value for this TV (store BEFORE the $ea_notes tag), and such explicit 
	''' user choices must never be overrided.
	''' 
	''' For "direct access" of the property content (without any semantics applied), 
	''' use the M_Value() or M_Default() instead.
	Private Function TryExtractRoleTagStereotypeDefault(ByRef S) ''': String, Boolean
		''' Example content :
		''' S = Value$ea_notes=Default: DefaultValue   
		m_startpos = InStr(1, S, "$ea_notes=Default:", 1)
		If m_startpos = 1 Then
			''' Try extracting to the right of "$ea_notes=Default:"
			m_startpos = m_startpos + 18 	''' 18 = Len("$ea_notes=Default:")
			S = Trim( Mid(S, m_startpos) )
			TryExtractRoleTagStereotypeDefault = True
		Else
			S = ""
			TryExtractRoleTagStereotypeDefault = False
		End If		
	End Function
	
	
	''' [PropertyTypeByName]
	Private Function PropertyTypeByName(aNameAsKey, ByRef OutProp) ''': PropertyType, Boolean
		''' OutResult type: EA.PropertyType
		If m_PropertyTypesDictionary.Exists(aNameAsKey) Then
			Set OutProp = m_PropertyTypesDictionary(aNameAsKey)
		Else
			Set OutProp = Nothing
		End If
		PropertyTypeByName = Not OutProp Is Nothing
	End Function
	
	
	''' [TryGetPropertyTypeDefault]
	Private Function TryGetPropertyTypeDefault(aNameAsKey, ByRef OutResult) ''': String, Boolean
		If m_PropertyTypesDefaultDictionary.Exists(aNameAsKey) Then
			OutResult = m_PropertyTypesDefaultDictionary(aNameAsKey)
			TryGetPropertyTypeDefault = OutResult <> ""
		Else
			OutResult = ""
			TryGetPropertyTypeDefault = False
		End If			
	End Function
	
	
	''' [RegisterPropertyTypes]
	''' Stores the very PropertyType object with the name as Key.
	Private Sub RegisterPropertyTypes() ''': Void
		Dim pt As EA.PropertyType
		
		For Each pt In Repository.PropertyTypes
			PropertyTypesDictionary.Add pt.Tag, pt
		Next
	End Sub
	
	
	''' [RegisterPropertyTypesDefaults]
	''' Stores the refined, extracted default value, as defined in 
	''' the PropertyType text "blob", into a Dictionary. The  
	''' name is used as the Key.
	Private Sub RegisterPropertyTypesDefaults() ''': Void
		Dim sRawData
		Dim sDefault
		Dim sPropNameKey
		
		For Each sPropNameKey In PropertyTypesRawDataDictionary.Keys
			''' Prepare / refine raw data before inserting it into the Dictionary
			sRawData = m_PropertyTypesRawDataDictionary(sPropNameKey)
			sDefault = ExtractPropertyFromRawStr(sRawData, "Default")
			
			'''Add to dictionary
			PropertyTypesDefaultDictionary.Add sPropNameKey, sDefault
		Next
	End Sub
	
	
	''' [RegisterPropertyTypesRawData]
	Private Sub RegisterPropertyTypesRawData() ''': Void
		Dim p As EA.PropertyType	
		Dim sTemp
		For Each p In Repository.PropertyTypes
			sTemp = p.Detail()
			''' Prepare the raw str for faster extraction (Lazy Eval)
			FormatPropertyTypesText sTemp 
			''' Store so it can later be retrieved ByName (= p.Tag)
			PropertyTypesRawDataDictionary.Add p.Tag, sTemp
		Next
	End Sub
	
	
	''' HELPER FUNCTIONS
	
	
	''' [GetValueByXmlTagName]
	''' Used for extracting single values from Repository.SQLQuery results (xml format).
	''' Omit the <> tags in aTagName.
	Private Function GetValueByXmlTagName(ByRef aStr, ByRef aTagName, ByRef OutResult) ''': String, Boolean
		Dim sTag
		
		m_startpos = 0
		m_endpos = 0
		sTag = "<" & aTagName & ">"
		''' Get first tag pos
		m_startpos = InStr(1, aStr, sTag, 1) + Len(aTagName)+2
		If m_startpos > 0 Then
			''' End tag pos
			m_endpos = InStr(1, aStr, "</" & aTagName & ">", 1)
			'' The value
			OutResult = Mid(aStr, m_startpos, m_endpos - m_startpos)
			GetValueByXmlTagName = True
		Else
			OutResult = ""
			GetValueByXmlTagName = False
		End If
	End Function
	
	
	''' [QueryRoleTagForElementID]
	''' Retrieves ElementID from EA.TagRole stored in "t_taggedvalue".  This 
	''' value is not exposed by the EA.RoleTag although there's a method for it.
	''' Be aware of that the property name (PropertyGUID) is not the same as 
	''' the table name (PropertyID).
	''' The resulting GUID to be used for fetching the parent Connector 
	''' from the table "t_connector". Code example:
	''' -----------------------------------------------------------------------
	''' If QueryRoleTagForElementID(m_rt, guid) Then _
	''' 	Set conn = Repository.GetConnectorByGuid(guid)
	''' -----------------------------------------------------------------------
	Private Function QueryRoleTagForElementID(ByRef OutGUID) ''': Boolean
		Dim result
		''' SQL - The query returns xml, in this format:
		''' -------------------------------------------------------------------
		'''		<EADATA version="1.0" exporter="Enterprise Architect">
		'''			<Dataset_0><Data><Row><ElementID>{D5C40150-0CE8-4c24-A635-C508623F9D45}</ElementID></Row></Data></Dataset_0></EADATA>	
		''' -------------------------------------------------------------------
		result = Repository.SQLQuery( _
    		"SELECT t_taggedvalue.ElementID " & _
    		"FROM t_taggedvalue " & _
    		"WHERE (PropertyID='" & m_rt.PropertyGUID & "');" _
    		)
		If GetValueByXmlTagName(result, "ElementID", result) And (result<>"") Then
			OutGUID = result
			QueryRoleTagForElementID = True
		Else
			OutGUID = ""
			QueryRoleTagForElementID = False
		End If
	End Function
	
	
	''' ----------------------------------
	''' EXTRACT (ANY) PROPERTY FROM STRING
	''' ----------------------------------
	''' [ExtractPropertyFromRawStr]
	''' EXTRACT VALUE FROM STRING
	''' * Result: Extracts named values from a "lump" field of multiple named 
	'''   property values. 
	''' * Entry : aSubjectStr MUST be treated with "FormatPropertyTypesText" before 
	'''	  calling this. Using Case IN-sensitive search for keywords.
	''' Example value as defined for an individual PropertyType (TaggedValue):
	'''  "Persistence : Type=Enum;
	'''   Values=Persistent;Transient;
	'''   Default=Persistent;
	'''   BaseStereotype=class;attribute;...etc;"
	Private Function ExtractPropertyFromRawStr(ByRef aSubjectStr, ByVal aFieldName) ''': Boolean
		Const vbCaseInSensitive = 1
		Dim pos_crlf
		Dim copy_len
		Dim eol_char
		Dim delimiter
		Dim result
		
		If aFieldName="" Then
			MsgBox "Error: Search string is empty!"
			ExtractPropertyFromRawStr = ""
			Exit Function
		End If
		
		aSubjectStr = aSubjectStr
		If InStr(1, aSubjectStr, ";", vbCaseInSensitive) > 0 Then
			MsgBox "Error: Subject string was not formatted using the method 'FormatPropertyTypesText'"
			ExtractPropertyFromRawStr = ""
			Exit Function
		End If
		
		result = ""
		
		''' Ensure traling "=" char to search for
		If Right(aFieldName, 1) <> "=" Then _
		aFieldName = aFieldName & "="
		
		m_startpos = 0
		m_startpos = InStr(1, aSubjectStr, aFieldName, 1)	''' 1 = Case Insensitive
		
		''' Check if value is "terminated" (=has a trailing ";" after the match)
		If m_startpos > 0 Then
			m_startpos = m_startpos + Len(aFieldName)
			
			''' Find the end of line
			eol_char = Chr(10)
			m_endpos = InStr(m_startpos, aSubjectStr, eol_char, 1)
			
			''' Check if a CRLF is located *before* the ";"
			pos_crlf = InStr(m_startpos, aSubjectStr, Chr(10), 1)
			
			''' If no CRLF exist, or is located *before* the ";" then that 
			''' (probably) means that a semicolon has been used as a delimiter 
			''' between values, and not only as a EOL char. Therefore, use LF 
			''' as the terminating char instead, and update the delimiter, as 
			''' well as the m_endpos (of line) accordingly.
			
			If (pos_crlf = 0) Or (pos_crlf > m_endpos) Then
				''' Update EOL pos
				m_endpos = pos_crlf
			End If
			
			''' Extract the value part
			If m_endpos > m_startpos Then 
				''' .......................................................
				''' Advance the start pos with the length of the search str
				''' Example: "... Default=<some value>; ... "
				'''               |    -->|
				''' .......................................................
				copy_len = m_endpos - m_startpos
				
				''' Extract
				result = Trim(Mid(aSubjectStr, m_startpos, copy_len))
			End If
		Else
			result = ""
		End If
		ExtractPropertyFromRawStr = result
	End Function
	
	
	''' [ContainsStr]
	''' Case INsensitive search
	Private Function ContainsStr(aStr, aChar)
		ContainsStr = InStr(1, aStr, aChar, 1) > 0	''' vbTextCompare
	End Function
	
	

    ''' [FormatPropertyTypesText]
    ''' Removes any delimiters from line ends, keeping 
    ''' only the LF. Thereafter all delimiters, like ";", 
    ''' are replaces with commas.
    ''' Ensures that the last line is treated like the other lines,
    ''' also meaning that Chr(10) (single LF) can be used as the 
    ''' terminating character.
    Private Sub FormatPropertyTypesText(ByRef aSubjectStr)
    	aSubjectStr = aSubjectStr & Chr(10)
    	
    	''' Consistent formatting for the rest (, as delimiter, and no ";" 
    	''' at the ned of lines) : 
    	
    	aSubjectStr = Replace(aSubjectStr, Chr(13), Chr(10), 1, -1, 1)
    	aSubjectStr = Replace(aSubjectStr, ";" & Chr(10), Chr(10), 1, -1, 1)
    	aSubjectStr = Replace(aSubjectStr, "," & Chr(10), Chr(10), 1, -1, 1)
    	aSubjectStr = Replace(aSubjectStr, ";", ",", 1, -1, 1)
    End Sub
	
	''' TRILTaggedValueApi
End Class

Module_Initialize
'
' END: ../Framework/Wrappers/TaggedValues/TaggedValue.vbs
' #######################

'
' #######################
' BEGIN: ../Framework/Wrappers/Scripting/SearchResults.vbs

'[path=\Framework\Wrappers\Scripting]
'[group=Wrappers]

' Already inlined !INC Utils.Include

'Author: Geert Bellekens
'Date: 2015-12-07
'dim outputTabName
'outputTabName = "ModelValidation"

Class SearchResults
'#region private attributes
	private m_Fields
	private m_Results
	private m_Name
'#endregion private attributes

'#region "Constructor"
	Private Sub Class_Initialize
		me.Fields = CreateObject("System.Collections.ArrayList")
		me.Results = CreateObject("System.Collections.ArrayList")
		me.Name = ""
	end sub
'#endregion "Constructor"
	
'#region Properties

	' Fields property
	Public Property Get Fields
	  set Fields = m_Fields
	End Property
	Public Property Let Fields(value)
	  set m_Fields = value
	End Property
	
	' Results property
	Public Property Get Results
	  set Results = m_Results
	End Property
	Public Property Let Results(value)
	  set m_Results = value
	End Property
	
	' Name property.
	Public Property Get Name
	  Name = m_Name
	End Property
	Public Property Let Name(value)
	  m_Name = value
	End Property	
'#endregion Properties
	
'#region functions
	'Show this resultset in the model search window
	public function Show()
		dim dataString
'		Repository.WriteOutput outputTabName, now() & " starting makeDataString",0
		dataString = makeSearchDataString()
'		Repository.WriteOutput outputTabName, now() & " Datastring: " & dataString,0
'		Repository.WriteOutput outputTabName, now() & " finished makeDataString",0
		Repository.RunModelSearch "","","", dataString
	end function
	
	private function makeSearchDataString()
		
		dim xmlDOM 
		set  xmlDOM = CreateObject( "Microsoft.XMLDOM" )
		'set  xmlDOM = CreateObject( "MSXML2.DOMDocument.4.0" )
		xmlDOM.validateOnParse = false
		xmlDOM.async = false
		 
		dim xmlRoot 
		set xmlRoot = xmlDOM.createElement( "ReportViewData" )
		dim uidAttr 
		set uidAttr = xmlDOM.createAttribute("UID")
		uidAttr.nodeValue = me.Name
		xmlRoot.setAttributeNode(uidAttr)
		xmlDOM.appendChild xmlRoot

		dim xmlFields
		set xmlFields = xmlDOM.createElement( "Fields" )
		xmlRoot.appendChild xmlFields
		'loop the fields
		dim field
		for each field in me.Fields
			dim xmlField 
			set xmlField = xmlDOM.createElement( "Field" )
			dim nameAttr
			set nameAttr = xmlDOM.createAttribute("name")
			nameAttr.nodeValue = field
			xmlField.setAttributeNode(nameAttr)
			xmlFields.appendChild xmlField
		next
		'add rows
		dim xmlRows
		set xmlRows = xmlDOM.createElement( "Rows" )
		xmlRoot.appendChild xmlRows
		'add row
		dim result, resultField, i
		for each result in me.Results
			dim xmlRow
			set xmlRow = xmlDOM.createElement( "Row" )
			xmlRows.appendChild xmlRow
			'add fields
			for i = 0 to result.Count -1
				resultField = result(i)
				field = m_Fields(i)
				'field attribute
				set xmlField = xmlDOM.createElement( "Field" )
				set nameAttr = xmlDOM.createAttribute("name")
				nameAttr.nodeValue = field
				'value attribute
				xmlField.setAttributeNode(nameAttr)
				dim valueAttr
				set valueAttr = xmlDOM.createAttribute("value")
				valueAttr.nodeValue = resultField
				xmlField.setAttributeNode(valueAttr)
				'add the field to the row
				xmlRow.appendChild xmlField
			next
		next
		'return
		makeSearchDataString = xmlDOM.xml
		
	end function
	
'#endregion functions	
End class
'
' END: ../Framework/Wrappers/Scripting/SearchResults.vbs
' #######################

'include the util group
' Already inlined !INC Utils.Include
'include the messages group
'
' #######################
' BEGIN: ../Framework/Wrappers/Messaging/Include.vbs

'[path=\Framework\Wrappers\Messaging]
'[group=Messaging]

!INC Local Scripts.EAConstants-VBScript

'
' #######################
' BEGIN: ../Framework/Wrappers/Messaging/Message.vbs

'[path=\Framework\Wrappers\Messaging]
'[group=Messaging]

' Already inlined !INC Utils.Include

' Author: Geert Bellekens
' Purpose: A wrapper class for a message node in a messaging structure
' Date: 2017-03-14

'Message types
const msgMIG6 = "MIG6"
const msgMIGDGO = "MIGDGO"
const msgMIGPPP = "MIGPPP"
const msgJSON = "JSON"

Class Message
	'private variables
	Private m_Name
	Private m_Alias
	Private m_RootNode
	Private m_MessageDepth
	Private m_BaseTypes
	Private m_Enumerations
	Private m_Prefix
	private m_ValidationRules
	Private m_MessageType
	Private m_IncludeDetails
	Private m_Fisses
	Private m_Version
	
	'constructor
	Private Sub Class_Initialize
		m_Name = ""
		m_Alias = ""
		set m_RootNode = nothing
		m_MessageDepth = 0
		set m_BaseTypes = CreateObject("Scripting.Dictionary")
		set m_Enumerations = CreateObject("Scripting.Dictionary")
		m_Prefix = ""
		set m_ValidationRules = CreateObject("System.Collections.ArrayList")
		m_MessageType = msgMIGDGO
		m_IncludeDetails = false
		set m_Fisses = nothing
		m_Version = ""
	End Sub
	
	'public properties
	
	' Name property.
	Public Property Get Name
	  Name = m_Name
	End Property
	Public Property Let Name(value)
	  m_Name = value
	End Property
		
	' Alias property.
	Public Property Get Alias
	  Alias = m_Alias
	End Property
	Public Property Let Alias(value)
	  m_Alias = value
	End Property
	
	' RootNode property.
	Public Property Get RootNode
	  set RootNode = m_RootNode
	End Property
	Public Property Let RootNode(value)
	  set m_RootNode = value
	End Property
	
	' MessageDepth property.
	Public Property Get MessageDepth
		if m_MessageDepth = 0 then
			m_MessageDepth = getMessageDepth()
		end if
		MessageDepth = m_MessageDepth
	End Property
	
	' BaseTypes property.
	Public Property Get BaseTypes
	  set BaseTypes = m_BaseTypes
	End Property
	
	' Enumerations property.
	Public Property Get Enumerations
	  set Enumerations = m_Enumerations
	End Property
	
	' Prefix property.
	Public Property Get Prefix
	  Prefix = m_Prefix
	End Property
	
	' ValidationRules property.
	Public Property Get ValidationRules
	  set ValidationRules = m_ValidationRules
	End Property
	Public Property Let ValidationRules(value)
	  set m_ValidationRules = value
	End Property
	
	'MessageType
	Public Property Get MessageType
	  MessageType = m_MessageType
	End Property
	Public Property Let MessageType(value)
		m_MessageType = value
	End Property
	
	' IncludeDetails property.
	Public Property Get IncludeDetails
		IncludeDetails = m_IncludeDetails
	End Property
	Public Property Let IncludeDetails(value)
		m_IncludeDetails = value
	End Property
	
	' Fisses property.
	Public Property Get Fisses
		if m_Fisses is nothing then
			loadFisses
		end if
		set Fisses = m_Fisses
	End Property
	Public Property Let Fisses(value)
		set Fisses = value
	End Property
	
	' HasMappings property.
	Public Property Get HasMappings
	  if me.RootNode.Mappings.Count > 0 then
		HasMappings = true
	  else
		HasMappings = false
	  end if
	End Property
	
	' Version property.
	Public Property Get Version
		if len(m_Version) = 0 then
			select case messageType
				case msgJSON
					m_version = me.RootNode.SourceElement.Version
				case else
					dim parentPackage as EA.Package
					set parentPackage = Repository.GetPackageByID(me.RootNode.SourceElement.PackageID)
					dim taggedValue as EA.TaggedValue
					for each taggedValue in parentPackage.Element.TaggedValues
						if lcase(taggedValue.Name) = "versionid" _
						  or lcase(taggedValue.Name) = "version" then
							m_Version = taggedValue.Value
							exit for
						end if
					next
			end select
		end if
		'return
		Version = m_Version
	End Property
	
	private function loadFisses()
		set m_Fisses = CreateObject("System.Collections.ArrayList")
		'MA(subset) -trace-> MA(messaging Model) -realize-> Message -realize-> FIS
		dim getFissesSQL
		getFissesSQL = "select fis.Object_ID from t_object o                                             " & _
					" inner join t_connector c on c.Start_Object_ID = o.Object_ID                      " & _
					" 							and c.Connector_Type = 'Abstraction'                   " & _
					" 							and c.Stereotype = 'trace'                             " & _
					" inner join t_object om on om.Object_ID = c.End_Object_ID                         " & _
					" 						and om.Name = o.Name                                       " & _
					" 						and om.Object_Type = o.Object_Type                         " & _
					" inner join t_connector omc on omc.Start_Object_ID = om.Object_ID                 " & _
					" 						 and omc.Connector_Type in ('Realization', 'Realisation')  " & _
					" inner join t_object msg on msg.object_ID = omc.End_Object_ID                     " & _
					" 						and msg.Object_Type = 'Class'                              " & _
					" 						and msg.Stereotype = 'Message'                             " & _
					" inner join t_connector msgc on msgc.Start_Object_ID = msg.Object_ID              " & _
					" 						 and msgc.Connector_Type in ('Realization', 'Realisation') " & _
					" inner join t_object fis on fis.Object_ID = msgc.End_Object_ID                    " & _
					" 						and fis.Object_Type = 'Class'                              " & _
					" 						and fis.Stereotype = 'Message'                             " & _
					" where o.Object_ID = " & me.RootNode.ElementID & "                                " & _
					" union                                                                            " & _
					" select fis.Object_ID from t_object o                                             " & _
					" inner join t_connector omc on omc.Start_Object_ID = o.Object_ID                  " & _
					" 						 and omc.Connector_Type in ('Realization', 'Realisation')  " & _
					" inner join t_object msg on msg.object_ID = omc.End_Object_ID                     " & _
					" 						and msg.Object_Type = 'Class'                              " & _
					" 						and msg.Stereotype = 'Message'                             " & _
					" inner join t_connector msgc on msgc.Start_Object_ID = msg.Object_ID              " & _
					" 						 and msgc.Connector_Type in ('Realization', 'Realisation') " & _
					" inner join t_object fis on fis.Object_ID = msgc.End_Object_ID                    " & _
					" 						and fis.Object_Type = 'Class'                              " & _
					" 						and fis.Stereotype = 'Message'                             " & _
					" where o.Object_ID =  " & me.RootNode.ElementID & "                               " & _
					" union                                                                            " & _
					" select fis.Object_ID from t_object o                                             " & _
					" inner join t_connector msgc on msgc.Start_Object_ID = o.Object_ID                " & _
					" 						 and msgc.Connector_Type in ('Realization', 'Realisation') " & _
					" inner join t_object fis on fis.Object_ID = msgc.End_Object_ID                    " & _
					" 						and fis.Object_Type = 'Class'                              " & _
					" 						and fis.Stereotype = 'Message'                             " & _
					" where o.Object_ID =  " & me.RootNode.ElementID & "                               " & _
					" and o.Stereotype = 'JSON_Schema'                                                 "
		dim fisses
		set fisses = getElementsFromQuery(getFissesSQL)
		dim fis as EA.Element
		for each fis in fisses
			m_Fisses.Add fis
		next
	end function
	
	public function loadMessage(eaRootNodeElement)
		
		'set the name of the message
		'the name of the message is equal to the name of the owning package
		dim ownerPackage as EA.Package
		set ownerPackage = Repository.GetPackageByID(eaRootNodeElement.PackageID)
		me.Name = ownerPackage.Name
		'set alias
		me.Alias = eaRootNodeElement.Alias
		'set the prefix
		m_Prefix = getPrefix(ownerPackage)
		'set MessageType (default = MIGDGO)
		dim rootNodeStereotypes
		dim rootNodeStereotype
		rootNodeStereotypes = split(eaRootNodeElement.StereotypeEx, ",")
		for each rootNodeStereotype in rootNodeStereotypes
			if rootNodeStereotype = "MA" then
				me.MessageType = msgMIG6
				'for message assemblies the name is stored on the element
				me.Name = eaRootNodeElement.Name
				exit for
			elseif rootNodeStereotype = "JSON_Schema" then
				me.MessageType = msgJSON
			end if
		next
		'if messagetype is still MIGDGO then check if this should not be PPP
		if me.MessageType = msgMIGDGO then
			if left(ownerPackage.Name,3) = "PPP" then
				me.MessageType = msgMIGPPP
			end if
		end if
		'create the root node
		me.RootNode = new MessageNode
		me.RootNode.IncludeDetails = me.IncludeDetails
		me.RootNode.Message = me
		me.RootNode.intitializeWithSource eaRootNodeElement, nothing, "1..1", nothing, nothing
		setBaseTypesAndEnumerations(me.RootNode)
		'link the message validation rules
		getMessageValidationRules()
	end function
	
	private function getPrefix(ownerPackage)
		getPrefix = ""
		dim taggedValue as EA.TaggedValue
		for each taggedValue in ownerPackage.Element.TaggedValues
			if taggedValue.Name = "targetNamespacePrefix" then
				getPrefix = taggedValue.Value
				exit for
			end if
		next
	end function
	
	private function getMessageValidationRules()
		dim getRulesElementsSQL
		getRulesElementsSQL = 	"select r.* from ((t_object o                                     " & _
								" inner join t_connector c on (c.End_Object_ID = o.Object_ID      " & _
								" 							and c.Connector_Type = 'Dependency' ))" & _
								" inner join t_object r on (c.Start_Object_ID = r.Object_ID       " & _
								" 						and r.Object_Type = 'Test'                " & _
								" 						and r.Stereotype = 'Message Test Rule'))  " & _
								" where o.Object_ID = " & me.RootNode.ElementID
		dim rulesElements
		set rulesElements = getElementsFromQuery(getRulesElementsSQL)
		dim rulesElement
		for each rulesElement in rulesElements
			dim validationRule
			set validationRule = new MessageValidationRule
			validationRule.initialiseWithTestElement(rulesElement)
			m_ValidationRules.Add validationRule
			'find the node this rule applies to ad add it to that node
			me.RootNode.linkRuletoNode validationRule, validationRule.Path
		next
	end function
	
	
	private function setBaseTypesAndEnumerations(messageNode)
		'check if messageNode is leafNode
		if messageNode.IsLeafNode then
			dim foundEnumeration
			foundEnumeration = false
			'check if the typeElement is an enumeration
			if not messageNode.TypeElement is nothing then
				if messageNode.TypeElement.Type = "Enumeration"_
				OR messageNode.TypeElement.Stereotype = "Enumeration" then
					foundEnumeration = true
					if not me.Enumerations.Exists(messageNode.TypeName) then
						'add to enumerations list
						me.Enumerations.Add messageNode.TypeName, messageNode.TypeElement
					end if
				end if
			end if
			'if we haven't found an enumeration we add the type to the basetypes
			if not foundEnumeration then
				if not me.BaseTypes.Exists(messageNode.TypeName) then
					'add to BaseTypes list
					me.BaseTypes.Add messageNode.TypeName, messageNode.TypeElement
				end if
			end if
		else
			'not a leafnode, check the childnodes
			dim childNode
			for each childNode in messageNode.ChildNodes
				setBaseTypesAndEnumerations childNode 
			next
		end if
		'add the base type to the list of types
		if not messageNode.BaseTypeElement is nothing then
			if messageNode.BaseTypeElement.Type = "Enumeration"_
			OR messageNode.BaseTypeElement.Stereotype = "Enumeration"  then
				if not me.Enumerations.Exists(messageNode.BaseTypeName) then
					'add to enumerations list
					me.Enumerations.Add messageNode.BaseTypeName, messageNode.BaseTypeElement
				end if
			else
				'add as base type
				if not me.BaseTypes.Exists(messageNode.BaseTypeName) then
					me.BaseTypes.Add messageNode.BaseTypeName, messageNode.BaseTypeElement
				end if
			end if
		end if
	end function
	
	'create an arraylist of arraylists with the details of this message
	public function createOuput(includeRules)
		dim outputList
		'create empty list for current path
		dim currentPath
		set currentPath = CreateObject("System.Collections.ArrayList")
		'start with the rootnode
		set outputList = me.RootNode.getOuput(1,currentPath,me.MessageDepth, includeRules)
		'return outputlist
		set createOuput = outputList
	end function
	
	'create an arraylist of arraylists with the details of this message
	public function createUnifiedOutput(includeRules, depth)
		dim outputList
		'create empty list for current path
		dim currentPath
		set currentPath = CreateObject("System.Collections.ArrayList")
		'start with the rootnode
		set outputList = me.RootNode.getOuput(1,currentPath,depth, includeRules)
		'return outputlist
		set createUnifiedOutput = outputList
	end function
	
	'create an arraylist of arraylists with the details of this message including he headers
	public function createFullOutput(includeRules)
		dim fullOutput
		dim headers
		set fullOutput = me.createOuput(includeRules)
		set headers = getHeaders(includeRules)
		'insert the headers before the rest of the output
		fullOutput.Insert 0, headers
		set createFullOutput = fullOutput
	end function
	
	'gets the maximum depth of this message
	private function getMessageDepth()
		dim message_depth
		message_depth = 0
		message_depth = me.RootNode.getDepth(message_depth)
		getMessageDepth = message_depth
	end function
	
	public function getHeaders(includeRules)
		set getHeaders = getMessageHeaders(includeRules, me.MessageDepth, me.MessageType, me.IncludeDetails, me.Fisses, me.HasMappings)
	end function
	
	private function getTypesHeaders()
		set getTypesHeaders = getMessageTypesHeaders(me.IncludeDetails)
	end function 
	
	Public function getUnifiedMessageTypes()
		set getUnifiedMessageTypes = getMyMessageTypes(true)
	end function
	
	private function getMyMessageTypes(unified)
		dim types
		set types = CreateObject("System.Collections.ArrayList")
		'add base types
		dim baseTypeName
		dim baseTypeElement
		dim elementOrder
		elementOrder = 0
		for each baseTypeName in me.BaseTypes.Keys
			elementOrder = elementOrder + 1
			set baseTypeElement = me.BaseTypes.Item(baseTypeName)
			if not IsObject(baseTypeElement) then
				set baseTypeElement = nothing
			end if
			if not baseTypeElement is nothing then
				if baseTypeElement.Stereotype <> "BDT" then
					'first add the properties for the base type itself
					dim baseTypeProperties
					set baseTypeProperties = getBaseTypeProperties(baseTypeElement, me.MessageType)
					if unified then
						'add the messageName
						baseTypeProperties.Insert 0, me.Name
					end if
					'add properties to list
					types.add baseTypeProperties
				end if
			end if
		next
		'add enumerations
		dim enumName
		dim enumElement as EA.Element
		for each enumName in me.Enumerations.Keys
			elementOrder = elementOrder + 1
			set enumElement = me.Enumerations.Item(enumName)
			'add all the literal values
			dim enumLiteral as EA.Attribute
			'if the enum has no values then ALL values are allowed
			'so we look for the enum this enum was based on
			if enumElement.Attributes.Count = 0 then
				'replace enumElement with base enum
				set enumElement = getBaseEnum(enumElement)
			end if
			'loop the enum literals
			for each enumLiteral in enumElement.Attributes
				elementOrder = elementOrder + 1
				dim enumLiteralProperties
				set enumLiteralProperties = getEnumLiteralProperties(enumElement,enumLiteral)
				if unified then
					'add the messageName
					enumLiteralProperties.Insert 0, me.Name
				end if
				types.add enumLiteralProperties
			next
		next
		'return the types
		set getMyMessageTypes = types
	end function
	
	private function getBaseEnum(enumElement)
		'initialize
		set getBaseEnum = nothing
		dim sqlGetBaseEnum
		sqlGetBaseEnum = "select o.Object_ID from t_object o                             " & _
						" inner join t_connector c on c.End_Object_ID = o.Object_ID      " & _
						" 							and c.Connector_Type = 'Abstraction' " & _
						" 							and c.Stereotype = 'trace'           " & _
						" where o.Object_Type = 'Enumeration'                            " & _
						" and c.Start_Object_ID = " & enumElement.ElementID & "          "
		dim baseEnums
		dim baseEnum as EA.Element
		set baseEnums = getElementsFromQuery(sqlGetBaseEnum)
		for each baseEnum in baseEnums
			set getBaseEnum = baseEnum
			exit for 'we only need the first one
		next
	end function
	
	Public function getMessageTypes()
		dim types
		set types = CreateObject("System.Collections.ArrayList")
		'first add the headers
		dim typeHeaders
		set typeHeaders = getTypesHeaders()
		'Session.Output typeHeaders.Count
		types.add typeHeaders
		'get the actual content
		types.AddRange getMyMessageTypes(false)
		'return the types
		set getMessageTypes = types
	end function
	
	Private function getEnumLiteralProperties(enumElement,enumLiteral)
		dim enumLiteralProperties 
		set enumLiteralProperties = CreateObject("System.Collections.ArrayList")
		'first fill the array with empty strings
		fillArrayList enumLiteralProperties, "", 6
		'category
		enumLiteralProperties(0) = "Enumeration"
		'Type
		enumLiteralProperties(1) = enumElement.Name
		'Code
		enumLiteralProperties(2) = "'" & enumLiteral.Name
		'Description
		enumLiteralProperties(3) = enumLiteral.Alias
		'Get the CodeName tagged value if it exists
		dim codeNameTv as EA.AttributeTag
		for each codeNameTv in enumLiteral.TaggedValues
			if lcase(codeNameTv.Name) = "codename" then
				enumLiteralProperties(3) = codeNameTv.Value
				exit for
			end if
		next
		'return the properties
		set getEnumLiteralProperties = enumLiteralProperties
	end function
	
	Private function getBaseTypeProperties(baseType, messageType)
		dim baseTypeProperties 
		set baseTypeProperties = CreateObject("System.Collections.ArrayList")
		'first fill the array with empty strings
		fillArrayList baseTypeProperties, "", 6
		'category
		baseTypeProperties(0) = "BaseType"
		'Type
		baseTypeProperties(1) = baseType.Name
		'Code
		baseTypeProperties(2) = "" 'emtpty for the base type
		'Description
		baseTypeProperties(3) = "" 'emtpty for the base type
		'Restriction Base
		dim derivedFrom
		derivedFrom = getDerivedFrom(baseType)
		baseTypeProperties(4) = derivedFrom
		'Facets
		'add properties based on the tagged values
		dim facetSpecification
		facetSpecification = "" 'initial value
		dim tv as EA.TaggedValue
		for each tv in baseType.TaggedValues
			if messageType = msgJSON then
				select case lcase(tv.Name)
					case tv_minlength, tv_maxlength, tv_pattern, tv_format, tv_enum, tv_minimum, _
					tv_exclusiveminimum, tv_maximum, tv_exclusivemaximum, tv_multipleof
						facetSpecification = addFacetSpecification(facetSpecification, tv)
				end select
			else
				select case tv.Name
					case tvxml_pattern, tvxml_enumeration, tvxml_fractionDigits, tvxml_length, tvxml_maxExclusive, _
					tvxml_maxInclusive, tvxml_maxLength, tvxml_minExclusive, tvxml_minInclusive, tvxml_minLength, _
					tvxml_totalDigits, tvxml_whiteSpace
						facetSpecification = addFacetSpecification(facetSpecification, tv)
				end select
			end if

		next
		baseTypeProperties(5) = facetSpecification
		'return the base type properties
		set getBaseTypeProperties = baseTypeProperties
	end function
	
	private function addFacetSpecification(facetSpecification, facetTV)
		addFacetSpecification = facetSpecification 'initial value
		if len(facetTV.Value) > 0 then
			if len(facetSpecification) > 0  then
				addFacetSpecification = addFacetSpecification & vbNewLine
			end if
			addFacetSpecification = addFacetSpecification & facetTV.Name & ": " & facetTV.Value
		end if
	end function
	
	private function fillArrayList(listToFill, fillValue, count)
		dim i
		for i = 0 to count -1 step +1
			listToFill.Add fillValue
		next
	end function
	
	private function getDerivedFrom(baseType)
		'the base type either inherits from a standard XSD type, or has it stored separately (gentype?)
		dim baseTypeBaseTypes 
		set baseTypeBaseTypes = baseType.BaseClasses
		dim derivedFrom as EA.Element
		set derivedFrom = nothing
		'get the first base class
		for each derivedFrom in baseType.BaseClasses
			exit for
		next
		if not IsObject(derivedFrom) then
			set derivedFrom = nothing
		end if
		'Check for CON attribute of BDT element
		if derivedFrom is nothing _
		and baseType.Stereotype = "BDT" then
			'get CON attributre
			dim attribute as EA.Attribute
			for each attribute in baseType.Attributes
				if attribute.Stereotype = "CON" _
				and attribute.ClassifierID > 0 then
					set derivedFrom = Repository.GetElementByID(attribute.ClassifierID)
				end if
			next
		end if
		'set name if derivedFrom element is found
		if not derivedFrom is nothing then
			getDerivedFrom = derivedFrom.Name
		else
			'if there is no real inheritance link then the link is stored in the genLinks property as parent=<name>;
			getDerivedFrom = getValueForkey(baseType.Genlinks, "parent")
		end if
		if getDerivedFrom = "anySimpleType" then
			'we are not interested in "anySimpletype"
			getDerivedFrom = ""
		end if
	end function
	
end Class

'"Static" functions

public function getMessageHeaders(includeRules, depth, messageType, technical, fisses, withMappings)
	dim headers
	set headers = CreateObject("System.Collections.ArrayList")
	'first order
	headers.add("Order")
	'then Message
	headers.Add("Message")
	'add the levels
	dim i
	for i = 1 to depth -1 step +1
		headers.add("L" & i)
	next
	'Cardinality
	headers.Add("Cardinality")
	'Type
	headers.Add("Type")
	'base type
	headers.Add("Base Type")
	'Constraints (facets)
	headers.Add("Constraints")
	if withMappings and not technical then
			'LDM mapping
			'LDM Class
			headers.Add("LDM Class")
			'LDM Attribute
			headers.Add("LDM Attribute")
	end if
	'add business usage
	if withMappings and not technical  _
	and not fisses is nothing then
		dim fis as EA.Element
		for each fis in fisses
			headers.Add fis.Name
		next
	end if
	if technical and _
	  messageType = msgJSON then
		headers.Add "Description"
	end if
	'add message test rules
	if includeRules then
		'with our without test rules
		'Test Rule ID
		headers.Add("Test Rule ID")
		'Test Rule
		headers.Add("Test Rule")
		'Error Reason
		headers.Add("Error Reason")
	end if
	'return the headers
	set getMessageHeaders = headers
end function

private function getMessageTypesHeaders(unified)
		dim headers
		set headers = CreateObject("System.Collections.ArrayList")
		'Message
		if unified then
			headers.Add("Message")
		end if
		'Category
		headers.Add("Category") 'Enumeration or BaseType '0
		'Type
		headers.Add("Type") '1
		'Code
		headers.Add("Code") '2
		'Description
		headers.Add("Description") '3
		'Restriction Base
		headers.Add("Restriction Base") '4
		'Facets
		headers.Add("Facets") '5
		'return the headers
		set getMessageTypesHeaders = headers
end function
'
' END: ../Framework/Wrappers/Messaging/Message.vbs
' #######################

'
' #######################
' BEGIN: ../Framework/Wrappers/Messaging/MessageNode.vbs

'[path=\Framework\Wrappers\Messaging]
'[group=Messaging]

' Already inlined !INC Utils.Include
!INC Local Scripts.EAConstants-VBScript
' Author: Geert Bellekens
' Purpose: A wrapper class for a message node in a messaging structure
' Date: 2017-03-14

	'JSON facet constants
	const tv_minlength = "minlength"
	const tv_maxlength = "maxlength"
	const tv_pattern = "pattern" 
	const tv_format = "format"
	const tv_enum = "enum"
	const tv_minimum = "minimum"
	const tv_exclusiveminimum = "exclusiveminimum"
	const tv_maximum = "maximum"
	const tv_exclusivemaximum = "exclusivemaximum"
	const tv_multipleof = "multipleof"
	
	'XML  facet constants
	const tvxml_pattern = "pattern"
	const tvxml_enumeration = "enumeration"
	const tvxml_fractionDigits = "fractionDigits"
	const tvxml_length = "length"
	const tvxml_maxExclusive = "maxExclusive"
	const tvxml_maxInclusive = "maxInclusive"
	const tvxml_maxLength = "maxLength"
	const tvxml_minExclusive = "minExclusive"
	const tvxml_minInclusive = "minInclusive"
	const tvxml_minLength = "minLength"
	const tvxml_totalDigits = "totalDigits"
	const tvxml_whiteSpace = "whiteSpace"

Class MessageNode 

	'private variables
	Private m_Name
	Private m_TypeElement
	Private m_TypeName
	Private m_Multiplicity
	Private m_ParentNode
	Private m_ChildNodes
	Private m_SourceAttribute
	Private m_SourceAssociationEnd
	Private m_SourceAssociation
	Private m_SourceElement
	Private m_mappingPath
	Private m_ValidationRules
	Private m_IsLeafNode
	Private m_Order
	Private m_Facets
	Private m_MappedBusinessAttributes
	Private m_IncludeDetails
	Private m_BaseTypeName
	Private m_BaseTypeElement
	Private m_Message
	Private m_Mappings
	Private m_Choices
	Private m_MappingPathString

	'constructor
	Private Sub Class_Initialize
		m_Name = ""
		set m_TypeElement = nothing
		m_TypeName = ""
		m_Multiplicity = ""
		set m_ParentNode = nothing
		set m_ChildNodes = CreateObject("System.Collections.ArrayList")
		set m_mappingPath = nothing
		set m_SourceAttribute = nothing
		set m_SourceAssociationEnd = nothing
		set m_SourceAssociation = nothing
		set m_SourceElement = nothing
		set m_ValidationRules = CreateObject("System.Collections.ArrayList")
		m_IsLeafNode = false
		m_order = 0
		set m_Facets = CreateObject("Scripting.Dictionary")
		set m_MappedBusinessAttributes = CreateObject("System.Collections.ArrayList")
		m_IncludeDetails = false
		m_BaseTypeName = ""
		set m_BaseTypeElement = nothing
		set m_Message = nothing
		set m_Mappings = nothing
		set m_Choices = nothing
		m_MappingPathString = ""
	End Sub
	
	'public properties
	
	' IsLeafNode property.
	Public Property Get IsLeafNode
		IsLeafNode = m_IsLeafNode
	End Property
	
	' IncludeDetails property.
	Public Property Get IncludeDetails
		if not me.ParentNode is nothing then
			IncludeDetails = me.ParentNode.IncludeDetails
		else
			IncludeDetails = m_IncludeDetails
		end if
	End Property
	Public Property Let IncludeDetails(value)
		m_IncludeDetails = value
	End Property
	
	' Name property.
	Public Property Get Name
		Name = m_Name
	End Property
	Public Property Let Name(value)
		m_Name = value
	End Property
	
	' Notes property.
	Public Property Get Notes
		if not me.SourceAttribute is nothing then
			Notes = me.SourceAttribute.Notes
		elseif not me.SourceAssociationEnd is nothing then
			if len (me.SourceAssociationEnd.Notes) > 0 then
				Notes = me.SourceAssociationEnd.Notes
			else 
				Notes = me.SourceAssociation.Notes
			end if
		elseif not me.SourceElement is nothing then
			Notes = me.SourceElement.Notes
		else
			Notes = ""
		end if
	End Property
	
	' TypeElement property.
	Public Property Get TypeElement
		set TypeElement = m_TypeElement
	End Property
	Public Property Let TypeElement(value)
		set m_TypeElement = value
	End Property

	' ElementID property.
	Public Property Get ElementID
		if not me.TypeElement is nothing then
			ElementID = me.TypeElement.ElementID
		else
			ElementID = 0
		end if
	End Property

	' TypeName property
	Public Property Get TypeName
		if not me.TypeElement is nothing then
			TypeName = me.TypeElement.Name
		else
			TypeName = m_TypeName
		end if 
	End Property
	Public Property Let TypeName(value)
		m_TypeName = value
		'if the typename if different from the TypeElement name then we remove the type Element
		if not me.TypeElement is nothing then
			if value <> me.TypeElement.Name then
				me.TypeElement = nothing
			end if
		end if
	End Property
	' BaseTypeElement property.
	Public Property Get BaseTypeElement
		set BaseTypeElement = m_BaseTypeElement
	End Property
	Public Property Let BaseTypeElement(value)
		set m_BaseTypeElement = value
	End Property
	
	' BaseTypeName property.
	Public Property Get BaseTypeName
		if not me.BaseTypeElement is nothing then
			BaseTypeName = me.BaseTypeElement.Name
		else
			BaseTypeName = m_BaseTypeName
		end if 
	End Property
	Public Property Let BaseTypeName(value)
		m_BaseTypeName = value
		'if the typename if different from the TypeElement name then we remove the type Element
		if not me.BaseTypeElement is nothing then
			if value <> me.BaseTypeElement.Name then
				me.BaseTypeElement = nothing
			end if
		end if
	End Property
		
	' Multiplicity property.
	' only directly used if the source is element, else we use the Attribute or AssociationEnd multiplicity
	Public Property Get Multiplicity
		dim lower
		dim upper
		dim returnedMultiplicity
		if not me.SourceElement is nothing then
			returnedMultiplicity = m_Multiplicity
		elseif not me.sourceAttribute is nothing then
			returnedMultiplicity = determineMultiplicity(me.sourceAttribute.LowerBound,me.sourceAttribute.UpperBound, "1", "1")
		elseif not me.sourceAssociationEnd is nothing then
			returnedMultiplicity = sourceAssociationEnd.Cardinality
		end if
		'return the actual value
		Multiplicity = returnedMultiplicity
	End Property
	Public Property Let Multiplicity(value)
		if not me.SourceElement is nothing then
			m_Multiplicity = value
		end if
	End Property
	
	private function determineMultiplicity(lower,upper,defaultLower, defaultUpper)
		'check to make sur the values are filled in and replace them with the default values if not the case
		if len(lower) = 0 then
			lower = defaultLower
		end if
		if len(upper) = 0 then
			upper = defaultUpper
		end if
		'create the multiplicity string
		determineMultiplicity = lower & ".." & upper
	end function
	' ParentNode property.
	Public Property Get ParentNode
		set ParentNode = m_ParentNode
	End Property
	Public Property Let ParentNode(value)
		set m_ParentNode = value
	End Property

	' ChildNodes property.
	Public Property Get ChildNodes
		set ChildNodes = m_ChildNodes
	End Property
	Public Property Let ChildNodes(value)
		set m_ChildNodes = value
	End Property
	
	' SourceAttribute property.
	Public Property Get SourceAttribute
		set SourceAttribute = m_SourceAttribute
	End Property
	Public Property Let SourceAttribute(value)
		set m_SourceAttribute = value
	End Property

	' SourceAssociationEnd property.
	Public Property Get SourceAssociationEnd
		set SourceAssociationEnd = m_SourceAssociationEnd
	End Property
	Public Property Let SourceAssociationEnd(value)
		set m_SourceAssociationEnd = value
	End Property
	
	' SourceAssociation property.
	Public Property Get SourceAssociation
		set SourceAssociation = m_SourceAssociation
	End Property
	Public Property Let SourceAssociation(value)
		set m_SourceAssociation = value
	End Property
	
	' SourceElement property.
	Public Property Get SourceElement
		set SourceElement = m_SourceElement
	End Property
	Public Property Let SourceElement(value)
		set m_SourceElement = value
	End Property
	
	' ValidationRules property.
	Public Property Get ValidationRules
		set ValidationRules = m_ValidationRules
	End Property
	Public Property Let ValidationRules(value)
		set m_ValidationRules = value
	End Property	
	
	'MessageType property
	Public Property Get MessageType
	  MessageType = me.Message.MessageType
	End Property
	
	'Order property
	Public Property Get Order
	  Order = m_Order
	End Property
	Public Property Let Order(value)
		m_Order = value
	End Property
	
	' Facets property. (Dictionary with key = facet name, value = facet value)
	Public Property Get Facets
		set Facets = m_Facets
	End Property
	Public Property Let Facets(value)
		set m_Facets = value
	End Property
		
	' MappedBusinessAttributes property.
	Public Property Get MappedBusinessAttributes
		set MappedBusinessAttributes = m_MappedBusinessAttributes
	End Property
	Public Property Let MappedBusinessAttributes(value)
		set m_MappedBusinessAttributes = value
	End Property
	
	' Message property.
	Public Property Get Message
		set Message = m_Message
	End Property
	Public Property Let Message(value)
		set m_Message = value
	End Property
	
	' MappingPathString property.
	Public Property Get MappingPathString
		if len(m_MappingPathString) = 0 then
			m_MappingPathString = getMappingPathString()
		end if
		MappingPathString = m_MappingPathString
	End Property
	
	Public Property Get MappingPath
		if m_MappingPath is nothing then
			set m_MappingPath = CreateObject("System.Collections.ArrayList")
			'add the parents mappingPath
			if not me.ParentNode is nothing then
				m_MappingPath.AddRange me.ParentNode.MappingPath
			end if
			'add own guid
			if not me.sourceAssociation is nothing then
				m_MappingPath.Add me.SourceAssociation.ConnectorGUID
			elseif not me.sourceAttribute is nothing then
				m_MappingPath.Add me.SourceAttribute.AttributeGUID
			elseif not me.sourceElement is nothing then
				m_MappingPath.Add me.SourceElement.ElementGUID
			end if
		end if
		set MappingPath = m_MappingPath
	End Property
	
	' Mappings property.
	Public Property Get Mappings
		if m_Mappings is nothing then
			loadMappings
		end if
		set Mappings = m_Mappings
	End Property
	
	' returns the other choices in the choice group
	Public Property Get Choices
		if m_Choices is nothing then
			set m_Choices = getChoices
		end if 
		'return
		set Choices = m_Choices
	End Property
	
	Private function loadMappings()
		'create the list if needed
		if m_Mappings is nothing then
			set m_Mappings = CreateObject("System.Collections.ArrayList")
		end if
		'get the maping tagged values and create mappings for them
		dim taggedValue as EA.TaggedValue
		dim taggedValues
		set taggedValues = getSourcetaggedValues()
		dim mapping
		for each taggedValue in taggedValues
			if lcase(taggedValue.Name) = lcase(linkedAttributeTag) _
			  or lcase(taggedValue.Name) = lcase(linkedAssociatonTag) _
			  or lcase(taggedValue.Name) = lcase(linkedElementTag)  then
				'add the mapping
				addNewMapping(taggedValue)
			end if
		next
	end function
	
	private function addNewMapping(taggedValue)
		'first check if the taggedValue represents this node
		dim mapping
		set mapping = new Mapping
		mapping.TaggedValue = taggedValue
		'check if each of the mappingPath guid's is present in the mappingPathString of the mappping
		dim found
		found = false
		dim guid
		for each guid in me.MappingPath
			if Instr(mapping.MappingPathString, guid) > 0 then
				found = true
			else
				found = false
				exit for
			end if
		next
		if found then
			if not mapping.Target is nothing then
				Repository.WriteOutput outPutName, now() & " Adding mapping from '" & me.Name & "' to '" & mapping.Target.Name & "'", 0
				m_Mappings.Add mapping
			else
				Repository.WriteOutput outPutName, now() & " ERROR: Mapping target missing on '" & me.Name, 0
			end if
		end if
	end function
	
	private function getChoices()
		dim tags
		dim tag as EA.TaggedValue
		set tags = getSourcetaggedValues()
		dim choices
		set choices = CreateObject("System.Collections.ArrayList")
		for each tag in tags
			if lcase(tag.Name) = "choice" then
				'split the value
				dim choiceGUIDs 
				choiceGUIDs = Split( tag.Value, ",")
				dim choiceGUID
				for each choiceGUID in choiceGUIDs
					dim choiceObject
					'remove spaces
					choiceGUID = trim(choiceGUID)
					'first try attribute
					set choiceObject = Repository.GetAttributeByGuid(choiceGUID)
					'then try connector
					if choiceObject is nothing then	
						set choiceObject = Repository.GetConnectorByGuid(choiceGUID)
					end if
					if not choiceObject is nothing then
						choices.Add choiceObject
					end if
				next
				exit for
			end if
		next
		'return 
		set getChoices = choices
	end function
	
	private function getSourcetaggedValues()
		dim sourceTags
		set sourceTags = CreateObject("System.Collections.ArrayList")
		dim item
		set item = nothing
		'figure out the real source
		if not me.SourceAttribute is nothing then
			set item = me.SourceAttribute
		elseif not me.SourceAssociation is nothing then
			set item = me.SourceAssociation
		elseif not me.SourceElement is nothing then
			set item = me.SourceElement
		end if
		'get the actual tagged values
		if not item is nothing then
			set sourceTags = item.TaggedValues
		end if
		'return the sourcetags
		set getSourcetaggedValues = sourceTags
	end function
		
	public function getMappingPathString()
		dim mappingPathString
		dim guid 
		for each guid in me.MappingPath
			if len(mappingPathString) > 0 then
				mappingPathString = mappingPathString & "."
			end if
			mappingPathString = mappingPathString & guid
		next
		getMappingPathString = mappingPathString
	end function
	
	Public function linkRuletoNode(validationRule, path)
		'initialize false
		linkRuletoNode = false
		if path.Count > 0 then
			if path.Count = 1 then
				'link it to this node
				m_ValidationRules.Add validationRule
				linkRuletoNode = true
			else
				'go deeper
				dim childNode
				for each childNode in me.ChildNodes
					dim newPath
					set newPath = nothing
					if path(1) = childNode.Name then
						if newPath is nothing then
							set newPath = CreateObject("System.Collections.ArrayList")
							'create new path removing the first part
							dim i
							for i = 1 to path.Count -1 step +1
								newPath.Add path(i)
								'return true
								linkRuletoNode = true
							next
						end if
						'go one level deeper
						linkRuletoNode = childNode.linkRuletoNode(validationRule, newPath)
					end if
				next
			end if
		end if
	end function
	
	'public functions
	public function intitializeWithSource(source,sourceConnector,in_multiplicity,in_validationRule,in_parentNode)
		'set validationRule
		if not in_validationRule is nothing then
			me.ValidationRule = in_validationRule
		end if
		'set parentNode
		if not in_parentNode is nothing then
			me.ParentNode = in_parentNode
		end if
		'check if source is Element, Atttribute, or AssociationEnd
		select case source.ObjectType
			case otElement
				setElementNode source,in_multiplicity
			case otAttribute
				setAttributeNode source
			case otConnectorEnd
				setConnectorEndNode source,sourceConnector
		end select
		Repository.WriteOutput outPutName, now() & " Processing node '" & me.Name & "'", 0
		'set the isLeafNode property
		setIsLeafNode
		'then load the child nodes
		if not me.IsLeafNode then
			loadChildNodes
		end if
	end function
	
	'set the source node in case the source is an element
	private function setElementNode(source,in_multiplicity)
		me.SourceElement = source
		me.Name = source.Name
		me.TypeElement = source
		me.Multiplicity = in_multiplicity
	end function
	
	'set the source in case of an attribute
	private function setAttributeNode(source)
		me.SourceAttribute = source
		'set the order
		me.Order = getSequencingKey(source)
		'set the name
		me.Name = source.Name
		'remove any underscores from the name in case of MIG6
		if me.MessageType = msgMIG6 then
			me.Name = Replace(me.Name, "_","")
		end if
		'set the type
		dim attributeTypeObject as EA.Element
		set attributeTypeObject = nothing
		if source.ClassifierID > 0 then
			set attributeTypeObject = Repository.GetElementByID(source.ClassifierID)
			'if the attributeTypeObject is a \xABBDT\xBB then we get the attribute with stereotype \xABCON\xBB and name "content" and use it's type as the typeElement
			if attributeTypeObject.Stereotype = "BDT" then
				'get the content attribute
				dim conAttribute as EA.Attribute
				set conAttribute = nothing
				for each conAttribute in attributeTypeObject.Attributes
					if conAttribute.Stereotype = "CON" _
					  and conAttribute.Name = "content" then
						exit for
					end if
				next
				if not conAttribute is nothing then
					'get the facets from the conAttribute as well
					getFacets conAttribute
					if conAttribute.ClassifierID > 0 then
						dim conTypeObject as EA.Element
						set conTypeObject = Repository.GetElementByID(conAttribute.ClassifierID)
						'check for directXSD types
						me.BaseTypeElement = getBaseType(attributeTypeObject, conTypeObject)
						me.TypeElement = attributeTypeObject
					else
						me.TypeElement = attributeTypeObject
						me.BaseTypeName = conAttribute.Type
					end if
				else
					'content attribute not found, set error
					me.TypeName = "Error: BDT " & attributeTypeObject & " has no content attribute"
				end if
			else
				'regular attribute
				me.TypeElement = attributeTypeObject
				'find the parent class (not for enumerations)
				if not (me.TypeElement.Type = "Enumeration" _
					or lcase(me.TypeElement.Stereotype) = "enumeration") then
					dim parentClass as EA.Element
					for each parentClass in attributeTypeObject.BaseClasses
						me.BaseTypeElement = parentClass
						exit for 'return immediate
					next
				end if
			end if
		else
			me.TypeName = source.Type
		end if
		'get the facets
		getFacets source
		'set the mapped BusinessAttributes
		if me.MessageType = msgMIG6 then 'only applicable for custom ordering
			dim taggedValue as EA.AttributeTag
			'find the tagged values with name mappedBusinessAttribute
			for each taggedValue in source.TaggedValues
				if lcase(taggedValue.Name) = "mappedbusinessattribute" then
					dim businessAttribute as EA.Attribute
					set businessAttribute = Repository.GetAttributeByGuid(taggedValue.Value)
					if not businessAttribute is nothing then
						MappedBusinessAttributes.Add businessAttribute
					end if
				end if
			next
		end if
	end function
	
	private function getBaseType(attributeTypeObject, conTypeObject)
		'initialize
		set getBaseType = conTypeObject
		'figure out of the attributeTypeObject has tagged value with name "directXSDType" and value "true"
		dim isDirectXSDType
		isDirectXSDType = false
		dim tv as EA.TaggedValue
		for each tv in attributeTypeObject.TaggedValues
			if lcase(tv.Name) = "directxsdtype" _
			and lcase(tv.Value) = "true" then
				isDirectXSDType = true
			end if
		next
		if isDirectXSDType then
			'find the parent class
			dim parentClass as EA.Element
			for each parentClass in attributeTypeObject.BaseClasses
				set getBaseType = parentClass
				exit for 'return immediate
			next
		end if
	end function
	
	'gets the facets from an attribute
	private function getFacets(sourceAttribute)
		if me.MessageType = msgJSON then
			getJSONFacets sourceAttribute
		else
			getXMLFacets sourceAttribute
		end if
	end function
	
	private function getXMLFacets(sourceAttribute)
		dim tv as EA.TaggedValue
		'first loop the facets of the datatype
		dim datatype as EA.Element
		if sourceAttribute.ClassifierID > 0 then
			set datatype = Repository.GetElementByID(sourceAttribute.ClassifierID)
			for each tv in datatype.TaggedValues
				if len(tv.Value) > 0 then
					setXMLFacet tv.Name, tv.Value
				end if
			next
		end if
		'first loop the standard facets
		for each tv in sourceAttribute.TaggedValues
			setXMLFacet tv.Name, tv.Value
		next
		'then the overridden facets
		for each tv in sourceAttribute.TaggedValues
			if left(tv.Name,len("override_")) = "override_" then
				setXMLFacet Replace(tv.Name,"override_",""), tv.Value
			end if
		next
	end function
	
	private function setXMLFacet(tagName, tagValue)
		select case tagName
			case tvxml_pattern, tvxml_enumeration, tvxml_fractionDigits, tvxml_length, tvxml_maxExclusive, tvxml_maxInclusive, _
			tvxml_maxLength, tvxml_minExclusive, tvxml_minInclusive, tvxml_minLength, tvxml_totalDigits, tvxml_whiteSpace
				me.Facets.Item(tagName) = tagValue
		end select
	end function
	
	private function getJSONFacets(sourceAttribute)
		'check if uniqueItems should true
		if sourceAttribute.UpperBound <> "1" _
			and sourceAttribute.AllowDuplicates = false then
			me.Facets.Item("uniqueItems") = "true"
		end if
		dim tv as EA.TaggedValue
		'first loop the facets of the datatype
		'TODO facets of the parent datatype?
		dim datatype as EA.Element
		if sourceAttribute.ClassifierID > 0 then
			set datatype = Repository.GetElementByID(sourceAttribute.ClassifierID)
			processDatatypeFacets datatype
		end if
		'then the facets of the attribute
		processJsonFacetTags sourceAttribute
		'then the overridden facets
		'Not implemented for JSON facets
	end function
	
	function processDatatypeFacets(datatype)
		'first do the base datatypes
		dim baseDataType as EA.Element
		for each baseDataType  in dataType.BaseClasses
			processDatatypeFacets baseDataType
		next
		'then process this datatype
		processJsonFacetTags datatype
	end function
	
	function processJsonFacetTags(item)
		dim tv as EA.TaggedValue
		for each tv in item.TaggedValues
			if len(tv.Value) > 0 then
				select case lcase(tv.Name)
					case tv_minlength,tv_maxlength, tv_pattern, tv_format, tv_enum, tv_multipleof
						'add facet
						me.Facets.Item(tv.Name) = tv.Value
					case tv_minimum
						me.Facets.Item(tv.Name) = tv.Value
						'remove exclusive minimum
						if me.Facets.Exists(tv_exclusiveminimum) then
							me.Facets.Remove tv_exclusiveminimum
						end if
					case tv_exclusiveminimum
						me.Facets.Item(tv.Name) = tv.Value
						'remove minimum
						if me.Facets.Exists(tv_minimum) then
							me.Facets.Remove tv_minimum
						end if
					case tv_maximum
						me.Facets.Item(tv.Name) = tv.Value
						'remove exclusive maximum
						if me.Facets.Exists(tv_exclusivemaximum) then
							me.Facets.Remove tv_exclusivemaximum
						end if
					case tv_exclusivemaximum
						me.Facets.Item(tv.Name) = tv.Value
						'remove maximum
						if me.Facets.Exists(tv_maximum) then
							me.Facets.Remove tv_maximum
						end if
				end select
			end if
		next
	end function
	
	'set the source in case of a connectorEnd
	private function setConnectorEndNode(source,sourceConnector)
		me.SourceAssociationEnd = source
		me.SourceAssociation = sourceConnector
		'set the order
		me.Order = getSequencingKey(sourceConnector)
		dim endObject as EA.Element
		'get the end object 
		if source.End = "Supplier" then
			set endObject = Repository.GetElementByID(sourceConnector.SupplierID)
		else
			set endObject = Repository.GetElementByID(sourceConnector.ClientID)
		end if
		'set the name = name of role + name of end object + remove underscores
		if len(source.Role) > 0 then
			me.Name = source.Role & endObject.Name
			me.Name = Replace(me.Name, "_","")
		else
			'use the end object name as rolename
			me.Name = endObject.Name
		end if 
		'set the type
		me.TypeElement = endObject
	end function
	
	public function getSequencingKey(sourceItem)
		'initialize at 0
		getSequencingKey = 0
		dim taggedValue as EA.TaggedValue
		for each taggedValue in sourceItem.TaggedValues
			if Lcase(taggedValue.Name) = "sequencingkey" then
				on error resume next
				getSequencingKey = CInt(taggedValue.Value)
				if Err.Number <> 0 then
					err.Clear
				end if
				on error goto 0
				exit for
			end if
		next
	end function
	
	'Loads the child nodes for this message (resursively until we have reached all the leaves)
	public function loadChildNodes()
		'first remember the list of parent elements
		dim parents
		set parents = getParents(nothing)
		'TODO: load in correct order?
		'load attributes
		loadAllAttributeNodes parents 
		'load associations
		loadAllAssociationNodes parents
		'load nested classes?
		'reorder nodes
		if me.MessageType = msgMIG6 then
			reOrderChildNodes
		end if
	end function
	
	public function reOrderChildNodes
		dim childNode
			dim i
		dim goAgain
		goAgain = false
		dim currentNode
		dim nextNode
		for i = 0 to me.ChildNodes.Count -2 step 1
			set currentNode = me.ChildNodes.Item(i)
			set nextNode = me.ChildNodes.Item(i +1)
			if  currentNode.Order > nextNode.Order then
				me.ChildNodes.RemoveAt(i +1)
				me.ChildNodes.Insert i, nextNode
				goAgain = true
			end if
		next
		'if we had to swap an element then we go over the list again
		if goAgain then
			reOrderChildNodes
		end if
	end function
	
	'gets the maximum depth of this node and add that to the given depth
	public function getDepth(in_depth)
		dim childNode
		dim maxDebth
		maxDebth = in_depth + 1
		for each childNode in me.ChildNodes
			dim currentDepth
			currentDepth = childNode.getDepth(in_depth +1)
			if currentDepth > maxDebth then
				maxDebth = currentDepth
			end if
		next
		getDepth = maxDebth
	end function
	
	'gets the output format for this node and its childnodes
	public function getOuput(current_order,currentPath,messageDepth, includeRules)
		'create the output
		dim nodeOutputList
		set nodeOutputList = CreateObject("System.Collections.ArrayList")
		dim currentNodeList
		'get the list for this node
		if me.ValidationRules.Count = 0 or not includeRules then
			set currentNodeList = getThisNodeOutput(current_order,currentPath, messageDepth,nothing, includeRules)
			'up or the order number
			current_order = current_order + 1
			'add the list for this node to the output
			nodeOutputList.Add currentNodeList
		else
			dim currentRule
			for each currentRule in me.ValidationRules
				set currentNodeList = getThisNodeOutput(current_order,currentPath, messageDepth,currentRule, includeRules)
				'up or the order number
				current_order = current_order + 1
				'add the list for this node to the output
				nodeOutputList.Add currentNodeList
			next
		end if
		'add this node to the currentPath
		dim mycurrentpath
		set myCurrentPath = CreateObject("System.Collections.ArrayList")
		myCurrentPath.AddRange(currentPath)
		myCurrentPath.Add me.Name
		'get the output for the child nodes
		dim childNode
		for each childNode in me.ChildNodes
			dim childOutPut
			set childOutPut = childNode.getOuput(current_order,myCurrentPath,messageDepth, includeRules)
			nodeOutputList.AddRange(childOutPut)
		next
		'return list
		set getOuput = nodeOutputList
	end function
	

	
	private function getThisNodeOutput(current_order,currentPath, messageDepth,validationRule, includeRules)
		'get the list for this node
		dim currentNodeList
		set currentNodeList = CreateObject("System.Collections.ArrayList")
		'add the order to the list
		currentNodeList.Add lpad(current_order,4,"0")
		'add the current Path tot he node list
		currentNodeList.AddRange(currentPath)
		'add this name of to the list
		currentNodeList.Add me.Name
		'add empty fields until the messageDepth
		dim i
		for i = currentNodeList.Count -1 to messageDepth -1  step +1
			currentNodeList.Add ""
		next
		'then add the other fields
		currentNodeList.Add me.Multiplicity
		'Add the name of the type 
		currentNodeList.Add me.TypeName
		'Add base type
		currentNodeList.Add me.BaseTypeName
		'add constraints (choices + facets)
		dim constraintSpec
		constraintSpec = getChoiceSpecification()
		if len(constraintSpec) > 0 then
			constraintSpec = constraintSpec & VBNewLine
		end if
		'add facets
		constraintSpec = constraintSpec & getFacetsSpecification()
		'add the constraints to the list
		currentNodeList.Add constraintSpec
		'add the business attribute mapping and facets
		if not me.Message is nothing then
			if me.Message.HasMappings _
			  and not me.IncludeDetails then
				'add LDM mapping
				dim LDMClass
				LDMClass = ""
				dim LDMAttribute
				LDMAttribute = ""
				dim commentsPerFis
				set commentsPerFis = CreateObject("Scripting.Dictionary")
				dim fis
				'set the default values
				for each fis in me.message.fisses
					commentsPerFis(fis.Name) = ""
				next
				'loop mappings
				dim j
				For j = 0 to me.Mappings.Count -1					
					dim mapping
					set mapping = me.Mappings.Item(j)
					if not mapping.IsEmpty then
						dim target 
						set target = mapping.target
						dim targetType 
						targetType = target.ObjectType
						if targetType = otElement then
							if me.Mappings.Count > 1 then
								'add newline if needed
								if len(LDMClass) > 0 then
									LDMClass = LDMClass & VBNewLine
								end if
								'add number
								LDMClass = LDMClass & j + 1 & ") "
							end if
							'add className
							LDMClass = LDMClass & target.Name
						elseif targetType = otAttribute then
							dim owner as EA.Element
							set owner = mapping.TargetParent
							if owner is nothing then
								set owner = Repository.GetElementByID(target.ParentID)
							end if
							if me.Mappings.Count > 1 then
								'add newline if needed
								if len(LDMClass) > 0 then
									LDMClass = LDMClass & VBNewLine
									LDMAttribute = LDMAttribute & VBNewLine
								end if
								'add number
								LDMClass = LDMClass & j + 1 & ") "
								LDMAttribute = LDMAttribute & j + 1 & ") "
							end if
							'add className
							LDMClass = LDMClass & owner.Name 'Class
							LDMAttribute = LDMAttribute & target.Name 'Attribute
						end if
					end if
					'process the mapping logics
					dim fisName
					for each fisName in commentsPerFis.Keys
						dim mapped
						mapped = false
						'set mapped true if no mapping logics exist
						if mapping.MappingLogics.Count = 0 then
							mapped = true
						end if
						'add newline if needed
						if len(commentsPerFis(fisName)) > 0 then
							commentsPerFis(fisName) = commentsPerFis(fisName) & VBNewLine
						end if
						'add mapping number
						if me.Mappings.Count > 1 then
							commentsPerFis(fisName) = commentsPerFis(fisName) & j + 1 & ") "							
						end if
						'add specific mapping logic
						dim mappingLogic
						for each mappingLogic in mapping.MappingLogics
							dim context
							set context = mappingLogic.Context
							if not context is nothing then
								if context.Name = fisName then
									mapped = true
									'add content for this context
									commentsPerFis(fisName) = commentsPerFis(fisName) & mappingLogic.Description
								end if
							else
								mapped = true
								'add content to all contexts
								commentsPerFis(fisName) = commentsPerFis(fisName) & mappingLogic.Description
							end if
						next
						if not mapped then
							'add "not mapped" for this FIS
							commentsPerFis(fisName) = commentsPerFis(fisName) & "not mapped"
						end if
					next
				next
				'add the fields to the output
				currentNodeList.Add LDMClass
				currentNodeList.Add LDMAttribute
			end if
		end if
		'add the business usage section
		if not me.Message is nothing then
			if not me.IncludeDetails _
			and me.Message.HasMappings then
				for each fis in me.Message.Fisses 
					'add the mapping logic per FIS
					currentNodeList.Add commentsPerFis(fis.Name)
				next
			end if
		end if
		'add notes of element or attribute in case of msgJSON
		if me.MessageType = msgJSON then
			currentNodeList.Add Repository.GetFormatFromField("TXT", me.Notes)
		end if
		'add the rules section
		if includeRules then
			if not validationRule is nothing then
				currentNodeList.Add validationRule.RuleId
				currentNodeList.Add validationRule.Name
				currentNodeList.Add validationRule.Reason
			else
				currentNodeList.Add ""
				currentNodeList.Add ""
				currentNodeList.Add ""
			end if
		end if
		'return output
		set getThisNodeOutput = currentNodeList
	end function
	
	private function getChoiceSpecification()
		dim choiceSpec
		choiceSpec = "" 'initialize empty string
		dim choiceObject as EA.Connector
		for each choiceObject in me.Choices
			if len(choiceSpec) = 0 then
				choiceSpec = "Choice group with ("
			else
				choiceSpec = choiceSpec & ", "
			end if
			'get name
			if choiceObject.ObjectType = otAttribute then
				choiceSpec = choiceSpec & choiceObject.Name
			else
				'connector
				dim endObject as EA.Element
				set endObject = Repository.GetElementByID(choiceObject.SupplierID)
				dim connectorName
				'set the name = name of role + name of end object + remove underscores
				if len(choiceObject.SupplierEnd.Role) > 0 then
					connectorName = choiceObject.SupplierEnd.Role & endObject.Name
					connectorName= Replace(connectorName, "_","")
				else
					'use the end object name as rolename
					connectorName = endObject.Name
				end if 
				choiceSpec = choiceSpec & connectorName
			end if
		next
		'close parentheses if needed
		if len(choiceSpec) > 0 then
			choiceSpec = choiceSpec & ")"
		end if
		'return
		getChoiceSpecification = choiceSpec
	end function
	
	private function getFacetsSpecification()
		'initialize with empty string
		getFacetsSpecification = ""
		dim key
		for each key in me.Facets.Keys
			if len(getFacetsSpecification) > 0 then
				getFacetsSpecification = getFacetsSpecification & vbNewLine
			end if
			getFacetsSpecification = getFacetsSpecification & key & ": " & me.Facets.Item(key)
		next
		'for functional format the enum values should be included as well
		if not me.IncludeDetails  then
			dim enumType
			set enumType = getEnumType()
			if not enumType is nothing then
				dim enumValuesDescription
				enumValuesDescription = ""
				dim test as EA.Element
				dim enumValue as EA.Attribute
				for each enumValue in enumType.Attributes
					if len(enumValuesDescription) > 0 then
						'add newline
						enumValuesDescription = enumValuesDescription & vbNewLine
					end if
					'add the name
					enumValuesDescription = enumValuesDescription & enumValue.Name
					if me.MessageType = msgMIG6 then
						'Description is stored in the tagged value CodeName
						dim tv as EA.AttributeTag
						for each tv in enumValue.TaggedValues
							if lcase(tv.Name) = "codename" then
								'add the description for this code
								enumValuesDescription = enumValuesDescription & " (" & tv.Value & ")"
								exit for
							end if
						next
					else
						'description is stored in the Alias
						enumValuesDescription = enumValuesDescription & " (" & enumValue.Alias & ")"
					end if
				next
				'add to facetSpecification
				if len(enumValuesDescription) > 0 then
					if len(getFacetsSpecification) > 0 then
						getFacetsSpecification = getFacetsSpecification & vbNewLine
					end if
					'add enum values
					getFacetsSpecification = getFacetsSpecification & "Values allowed:" & VbNewLine & enumValuesDescription
				end if
			end if
		end if
	end function
	
	private function getEnumType()
		'initialize null
		set getEnumType = nothing
		'check if type element is enum
		if not me.TypeElement is nothing then
			if me.TypeElement.Type = "Enumeration" then
				set getEnumType = me.TypeElement
			end if
		end if
		if getEnumType is nothing _ 
		and not me.BaseTypeElement is nothing then
			if me.BaseTypeElement.Type = "Enumeration" then
				set getEnumType = me.BaseTypeElement
			end if
		end if
	end function
	
	'returns a list of all generalized elements of this elemnt
	private function getParents(childElement)
		dim directParents 
		dim sqlGetParents
		dim allParents
		set allParents = CreateObject("System.Collections.ArrayList")
		dim childElementID
		if not childElement is nothing then
			childElementID = childElement.ElementID
		else
			childElementID = me.ElementID
		end if
		sqlGetParents = "select c.End_Object_ID as Object_ID from t_connector c			 "  & _
						" where c.Connector_Type in ('Generalization','Generalisation')	 "  & _
						" and c.Start_Object_ID =" & childElementID
		set directParents = getElementsFromQuery(sqlGetParents)
		'add the direct parent to the list of all parents
		allParents.AddRange(directParents)
		'loop the parent and get their parents
		dim parent
		for each parent in directParents
			allParents.AddRange(getParents(parent))
		next
		'return
		set getParents = allParents
	end function
	'loads all Attribute notes both from this element as from its parents
	private function loadAllAttributeNodes(parents)
		'first load fro this element
		dim allAttributeNodes
		set allAttributeNodes = loadAttributeChildNodes(nothing)
		'then the one from the parents
		dim parent
		for each parent in parents
			allAttributeNodes.AddRange loadAttributeChildNodes(parent)
		next
	end function
	private function loadAttributeChildNodes(currentElement)
		set loadAttributeChildNodes = CreateObject("System.Collections.ArrayList")
		dim ownerElementID
		if not currentElement is nothing then
			ownerElementID = currentElement.ElementID
		else
			ownerElementID = me.ElementID
		end if
		'get attributes in the correct order (not for enum values
		dim SQLGetAttributes
		SQLGetAttributes = 	"select a.ID from (t_attribute a                             " & _
							" inner join t_object o on a.Object_ID = o.Object_ID)        " & _
							" where o.Object_Type <> 'Enumeration'                       " & _
							" and (o.Stereotype is null or o.Stereotype <> 'Enumeration')" & _
							" and a.Object_ID = " & ownerElementID & "                   " & _
							" and (a.Stereotype is null or a.Stereotype <> 'CON')        " & _
							" order by a.Pos, a.Name                                     "
		dim attributes
		set attributes = getattributesFromQuery(SQLGetAttributes)
		'loop the attributes
		dim attribute as EA.Attribute
		for each attribute in attributes
			'create the next messageNode
			dim newMessageNode
			set newMessageNode = new MessageNode
			newMessageNode.Message = me.Message
			'initialize
			newMessageNode.intitializeWithSource attribute, nothing, "", nothing, me
			'add to the childnodes list
			me.ChildNodes.Add newMessageNode
			'add to the output
			loadAttributeChildNodes.Add newMessageNode
		next
	end function
	
	'loads all Association nodes both from this element as from its parents
	private function loadAllAssociationNodes(parents)
		'first load for this element
		dim allAssociationNodes
		set allAssociationNodes = loadAssociationChildNodes(nothing)
		'then the ones from the parents
		dim parent
		for each parent in parents
			allAssociationNodes.AddRange loadAssociationChildNodes(parent)
		next
	end function
	
	private function loadAssociationChildNodes(currentElement)
		set loadAssociationChildNodes = CreateObject("System.Collections.ArrayList")
		dim ownerElementID
		if not currentElement is nothing then
			ownerElementID = currentElement.ElementID
		else
			ownerElementID = me.ElementID
		end if
		'get associations
		dim SQLAssociations
		SQLAssociations = 	"select c.Connector_ID from (t_connector c " & _
							" left join t_connectortag tv on (tv.ElementID = c.Connector_ID " & _
							" 						and tv.Property = 'sequencingKey')) " & _
							" where c.SourceIsAggregate > 0 " & _
							" and c.Start_Object_ID = " & ownerElementID & "  " & _         
							" order by tv.VALUE"
		dim associations
		set associations = getConnectorsFromQuery(SQLAssociations)
		'loop the associations
		dim association as EA.Connector
		for each association in associations
			'create the next messageNode
			dim newMessageNode
			set newMessageNode = new MessageNode
			newMessageNode.Message = me.Message
			'initialize
			newMessageNode.intitializeWithSource association.SupplierEnd, association, "", nothing, me
			'add to the childnodes list
			me.ChildNodes.Add newMessageNode
			'add to the output
			loadAssociationChildNodes.Add newMessageNode
		next
	end function
	
	private function setIsLeafNode()
		if not me.TypeElement is nothing then
			if me.TypeElement.Type = "Enumeration"_
			OR me.TypeElement.Stereotype = "Enumeration" _
			OR me.TypeElement.Stereotype = "XSDsimpleType" _
			OR me.TypeElement.Stereotype = "PRIM" then
				'enumerations and simple types are always leaf nodes
				m_IsLeafNode = true
			' a BDT is only a leafnode if it doesn't have any attributes except for the CON(tent)
			elseif me.TypeElement.Stereotype = "BDT" then
				m_IsLeafNode = true
				dim attribute as EA.Attribute
				for each attribute in me.TypeElement.Attributes
					if attribute.Stereotype <> "CON" then
						m_IsLeafNode = false
					end if
				next
			else
				m_IsLeafNode = false
			end if
		else
			m_IsLeafNode = true
		end if
	end function
	
end Class
'
' END: ../Framework/Wrappers/Messaging/MessageNode.vbs
' #######################

'
' #######################
' BEGIN: ../Framework/Wrappers/Messaging/MessageValidationRule.vbs

'[path=\Framework\Wrappers\Messaging]
'[group=Messaging]

' Author: Geert Bellekens
' Purpose: A wrapper class for a message validation rule
' Date: 2017-03-20

Class MessageValidationRule
	'private variables
	Private m_Name
	Private m_RuleID
	private m_Reason
	private m_TestElement
	private m_Path
	
	'constructor
	Private Sub Class_Initialize
		m_Name = ""
		m_RuleID = ""
		m_Reason = ""
		set m_TestElement = nothing
		set m_Path = CreateObject("System.Collections.ArrayList")
	End Sub
	
	'public properties
	
	' Name property.
	Public Property Get Name
	  Name = m_Name
	End Property
	Public Property Let Name(value)
	  m_Name = value
	End Property
	
	' RuleId property.
	Public Property Get RuleId
	  RuleId = m_RuleId
	End Property
	Public Property Let RuleId(value)
	  m_RuleId = value
	End Property
	
	' Reason property.
	Public Property Get Reason
	  Reason = m_Reason
	End Property
	Public Property Let Reason(value)
	  m_Reason = value
	End Property	
	
	' Path property.
	Public Property Get Path
	  set Path = m_Path
	End Property
	Public Property Let Path(value)
	  set m_Path = value
	End Property
	
	'test element property
	Public Property Get TestElement
	  set TestElement = m_TestElement
	End Property
	Public Property Let TestElement(value)
	  initialiseWithTestElement value
	End Property

	
	'public operations
	public function initialiseWithTestElement(testElement)
		set m_testElement = testElement
		me.Name = Repository.GetFormatFromField("TXT",m_testElement.Notes)
		me.RuleId = m_testElement.Name
		me.Reason = getTaggedValueValue(testElement, "Error Reason")
		'get the value of the path tagged value
		dim pathString
		pathString = getTaggedValueValue(m_testElement, "Constraint Path")
		if len(pathString) > 0 then
			dim part
			for each part in Split(pathString,".")
				m_Path.Add part
			next
		end if		
	end function
	
	
end Class
'
' END: ../Framework/Wrappers/Messaging/MessageValidationRule.vbs
' #######################

'
' END: ../Framework/Wrappers/Messaging/Include.vbs
' #######################

'include the OCL group
'
' #######################
' BEGIN: ../Framework/OCL/Include.vbs

'[path=\Framework\OCL]
'[group=OCL]

'
' #######################
' BEGIN: ../Framework/OCL/OCLStatement.vbs

'[path=\Framework\OCL]
'[group=OCL]


'Author: Geert Bellekens
'Date: 2017-11-24
'Purpose: Class containing a single OCL statement

Class OCLStatement
'#region private attributes
	private m_Context
	private m_LeftHand
	private m_NextOCLStatement
	private m_Operator
	private m_RightHand
	private m_Statement
	private m_IsValid
	
	private regexp
'#endregion private attributes

'#region "Constructor"
	Private Sub Class_Initialize
		Set regexp = CreateObject("VBScript.RegExp")
		regexp.Global = True   
		regexp.IgnoreCase = False
		set m_NextOCLStatement = nothing
	end sub
'#endregion "Constructor"
	
'#region Properties
	'Context property (EA.Element)
	Public Property Get Context
	  set Context = m_Context
	End Property
	Public Property Let Context(value)
	  set m_Context = value
	End Property
	
	'LeftHand property (string)
	Public Property Get LeftHand
	  LeftHand = m_LeftHand
	End Property
	Public Property Let LeftHand(value)
	  m_LeftHand = value
	End Property
	
	' NextOCLStatement property (OCLStatement)
	Public Property Get NextOCLStatement
	  set NextOCLStatement = m_NextOCLStatement
	End Property
	Public Property Let NextOCLStatement(value)
	  set m_NextOCLStatement = value
	End Property
	' Operator property (string) - 
	' can be "=", "->size()=", "->forAll(", "->notEmpty()"
	Public Property Get Operator
	  Operator = m_Operator
	End Property
	Public Property Let Operator(value)
	  m_Operator = replace(value, " ","")
	End Property
	
	' RightHand property (string)
	Public Property Get RightHand
	  RightHand = m_RightHand
	End Property
	Public Property Let RightHand(value)
	  m_RightHand = value
	End Property	
	
	' Statement property (string), contain the whole string
	Public Property Get Statement
	  Statement = m_Statement
	End Property
	Public Property Let Statement(value)
	  m_Statement = value
	  parseStatement()
	End Property
	
	'IsValid property (boolean)
	Public Property Get IsValid
	  IsValid = m_IsValid
	End Property
	Public Property Let IsValid(value)
	  m_IsValid = value
	End Property
	
	'ConstraintType property (enum (int) either OCLEqual or OCLMultiplicity )
	Public Property Get ConstraintType
		if left(trim(me.Operator), 1) = "=" then
			ConstraintType = OCLEqual
		elseif me.Operator = "choice" then
			ConstraintType = OCLChoice
		elseif lcase(me.Operator) = "->fractionaldigits()=" then
			ConstraintType = OCLfractionDigits
		elseif lcase(me.Operator) = "->length()=" then
			ConstraintType = OCLlength
		elseif lcase(me.Operator) = "->maxexclusive()=" then
			ConstraintType = OCLmaxExclusive
		elseif lcase(me.Operator) = "->maxinclusive()=" then
			ConstraintType = OCLmaxInclusive
		elseif lcase(me.Operator) = "->maxlength()=" then
			ConstraintType = OCLmaxLength
		elseif lcase(me.Operator) = "->minexclusive()=" then
			ConstraintType = OCLminExclusive
		elseif lcase(me.Operator) = "->mininclusive()=" then
			ConstraintType = OCLminInclusive
		elseif lcase(me.Operator) = "->minlength()=" then
			ConstraintType = OCLminLength
		elseif lcase(me.Operator) = "->pattern()=" then
			ConstraintType = OCLpattern			
		elseif lcase(me.Operator) = "->totaldigits()=" then
			ConstraintType = OCLtotalDigits
		elseif lcase(me.Operator) = "->whitespace()=" then
			ConstraintType = OCLwhiteSpace				
		else
			'can there be other types?
			ConstraintType = OCLMultiplicity
		end if
	End Property
	public Property Get FacetName
		select case me.ConstraintType
			case OCLfractionDigits
				FacetName = "fractionDigits"
			case OCLlength
				FacetName = "length"
			case OCLmaxExclusive
				FacetName = "maxExclusive"
			case OCLmaxInclusive
				FacetName = "maxInclusive"
			case OCLmaxLength
				FacetName = "maxLength"
			case OCLminExclusive
				FacetName = "minExclusive"
			case OCLminInclusive
				FacetName = "minInclusive"
			case OCLminLength
				FacetName = "minLength"
			case OCLpattern
				FacetName = "pattern"
			case OCLtotalDigits
				FacetName = "totalDigits"
			case OCLwhiteSpace		
				FacetName = "whiteSpace"
			case Else 
				FacetName = ""
			end select
	End Property
	public Property Get IsFacet
		isFacet = len(me.FacetName) > 0
	end property
	
'#endregion Properties
	
'#region functions
	'Show this resultset in the model search window
	public function parseStatement()
		'remove leading whitespace
		regExp.Pattern = "^\s*"
		m_Statement = regExp.Replace(me.Statement, "")
		'remove trailing whitespace
		regExp.Pattern = "\s*$"
		m_Statement = regExp.Replace(me.Statement, "")
		'fix "-> " to "->"
		regExp.Pattern = "-> "
		m_Statement = regExp.Replace(me.Statement, "->")
		'fix " ->" to "->"
		regExp.Pattern = "-> "
		m_Statement = regExp.Replace(me.Statement, "->")
		'fix "() =" to "()="
		regExp.Pattern = "\(\) ="
		m_Statement = regExp.Replace(me.Statement, "()=")
		'fix "= " to "="
		regExp.Pattern = "=\s"
		m_Statement = regExp.Replace(me.Statement, "=")
		dim matches
		'group into left(1), operator(2) and right(3)
		'regExp.Pattern = "(^.*?)(->size\(\)=?|->isEmpty\(\)|->notEmpty\(\)|->forAll ?\(|=)(?=[\s\S]+$)?([\s\S]+$)?"
		regExp.Pattern = "(^.*?)(->fractionalDigits\(\)=|->length\(\)=|->maxExclusive\(\)=|->maxInclusive\(\)=|->maxLength\(\)=|->minExclusive\(\)=|->minInclusive\(\)=|->minLength\(\)=|->pattern\(\)=|->totalDigits\(\)=|->whiteSpace\(\)=|->size\(\)=?|->isEmpty\(\)|->notEmpty\(\)|->forAll ?\(|=)(?=[\s\S]+$)?([\s\S]+$)?"
		set matches = regExp.Execute(me.Statement)
		dim match
		if matches.Count = 1 then
			set match = matches(0)
			if match.SubMatches.Count >=2 then
				'create new OCL statements
				me.LeftHand = match.SubMatches(0)
				me.Operator = match.SubMatches(1)
				if match.SubMatches.Count = 3 then
					me.RightHand = match.SubMatches(2)
					me.IsValid = true 'always valid if 
					me.ParseSubStatements()				
				else
					if me.Operator = "->notEmpty()" _
						or me.Operator = "->isEmpty()" then 'only case in which there are only two matches
						me.IsValid = true
					else
						me.IsValid = false
					end if
				end if

			else
				'Indicate not valid
				me.IsValid = false
			end if
		else
			'there should only be one match
			me.IsValid = false
		end if
		
	end function
	
	function ParseSubStatements()
		'check if the statement exists of multiple statements (starting with self.)
		regExp.Pattern = "(\S*)[\s]*?or[ \s]*(self\.[\s\S]*)$"
		dim matches
		set matches = regExp.Execute(me.RightHand)
		if matches.Count = 1 then
			dim match
			set match = matches(0)
			if match.SubMatches.Count =2 then
				'get the limited right part
				me.RightHand = match.SubMatches(0)
				'create next statement
				me.NextOCLStatement = new OCLStatement
				me.NextOCLStatement.Context = me.Context
				me.NextOCLStatement.Statement = match.SubMatches(1)
			end if
		else
			'check if there are multiple statements for a value (used in Forall ( x = y or w = z))
			regExp.Pattern = "(\S*) ?= ?(\S*)[\s]*?or[ \s]*([\s\S]*\)\s*)$"
			set matches = regExp.Execute(me.RightHand)
			if matches.Count = 1 then
				set match = matches(0)
				if match.SubMatches.Count =3 then
					'create next statement
					me.NextOCLStatement = new OCLStatement
					me.NextOCLStatement.Context = me.Context
					me.NextOCLStatement.Statement = me.LeftHand & me.Operator & match.SubMatches(2)
					'then reset this statement to simple "=" statement
					me.LeftHand = me.LeftHand & "." & match.SubMatches(0)
					me.Operator = "="
					me.RightHand = match.SubMatches(1)
				end if
			else
				'check if partial statement between brackets (used in ForAll (x=y))
				if lcase(left(me.Operator,8)) = "->forall" then
					regExp.Pattern = "(^.*?) ?(->fractionalDigits\(\)=|->length\(\)=|->maxExclusive\(\)=|->maxInclusive\(\)=|->maxLength\(\)=|->minExclusive\(\)=|->minInclusive\(\)=|->minLength\(\)|->pattern\(\)=|->totalDigits\(\)=|->whiteSpace\(\)=|->size\(\)=?|->isEmpty\(\)|->notEmpty\(\)|=) ?(\S*)\s*?\)\s*?$"
					set matches = regExp.Execute(me.RightHand)
					if matches.Count = 1 then
						set match = matches(0)
						if match.SubMatches.Count >= 2 then
							me.LeftHand = me.LeftHand & "." & match.SubMatches(0)
							me.Operator = match.SubMatches(1)
							if match.SubMatches.Count = 3 then
								me.RightHand = match.SubMatches(2)
							else
								me.RightHand = ""
							end if
						end if
					end if
				else
					'check if statement is an implies statement (choice)
					regExp.Pattern = "\w?\s+implies\s+(self\..+)"
					set matches = regExp.Execute(me.RightHand)
					if matches.Count = 1 then
						set match = matches(0)
						if match.SubMatches.Count =1 then
							'create next statement
							me.NextOCLStatement = new OCLStatement
							me.NextOCLStatement.Context = me.Context
							me.NextOCLStatement.Statement = match.SubMatches(0)
							'then reset this statement to choice
							me.Operator = "choice"
						end if
					end if
				end if
			end if
		end if
	end function
'#endregion functions	
end class

'declare "enum" values for constraint type
dim OCLEqual, OCLMultiplicity, OCLChoice,OCLfractionDigits, OCLlength, OCLmaxExclusive, OCLmaxInclusive, OCLmaxLength, OCLminExclusive, _
OCLminInclusive, OCLminLength, OCLpattern, OCLtotalDigits, OCLwhiteSpace
OCLEqual = 1
OCLMultiplicity = 2
OCLChoice = 3
OCLfractionDigits = 4
OCLlength = 5
OCLmaxExclusive = 6
OCLmaxInclusive = 7
OCLmaxLength = 8
OCLminExclusive = 9
OCLminInclusive = 10
OCLminLength = 11
OCLpattern = 12
OCLtotalDigits = 13
OCLwhiteSpace = 14
'
' END: ../Framework/OCL/OCLStatement.vbs
' #######################

'
' #######################
' BEGIN: ../Framework/OCL/Schema.vbs

'[path=\Framework\OCL]
'[group=OCL]


'Author: Geert Bellekens
'Date: 2017-12-06
'Purpose: Class representing a Schema Composer Schema

Class Schema 
	'private variables
	Private m_Artifact
	Private m_Context
	Private m_Elements
	Private m_Owner
	'constructor
	Private Sub Class_Initialize
		set m_Artifact = nothing
		set m_Context = nothing
		set m_Elements = CreateObject("Scripting.Dictionary")
	End Sub
	
	' Artifact property (EA.Element)
	Public Property Get Artifact
	 set Artifact = m_Artifact
	End Property
	Public Property Let Artifact(value)
	  set m_Artifact = value
	End Property
	
	' Context property (EA.Element)
	Public Property Get Context
	 set Context = m_Context
	End Property
	Public Property Let Context(value)
		set m_Context = value
		'add the context as a SchemaElement
		dim contextSchemaElement
		set contextSchemaElement = addSchemaElement(me.Context, me.Context.Name, false)
		contextSchemaElement.IsRoot = true
	End Property
	
	' Elements property (Dictionary of source element GUID and SchemaElements)
	Public Property Get Elements
	 set Elements = m_Elements
	End Property
	Public Property Let Elements(value)
	  set m_Elements = value
	End Property
	
	' Owner property (Schema)
	Public Property Get Owner
	 set Owner = m_Owner
	End Property
	Public Property Let Owner(value)
	  set m_Owner = value
	End Property
	
	'saves the schema to the artifact
	Public function save()
		'create artifact
		dim artifact as EA.Element
		set artifact = createArtifact()
		'get XML
		dim xmlString
		xmlString = getXML()
		'create new record in t_document
		createTDocument artifact, xmlString
	end function
	
	function createTDocument(artifact, xmlString)
		dim timestamp
		timestamp = Year(now()) & "-" & Month(now()) & "-" & Day(now()) & " " & Hour(now()) & ":" & Minute(now) & ":" & Second(now())
		dim sqlCreateSchemaDocument
		sqlCreateSchemaDocument = " INSERT INTO [dbo].[t_document]             " & vbNewLine & _
								"            ([DocID]                        " & vbNewLine & _
								"            ,[DocName]                      " & vbNewLine & _
								"            ,[Notes]                        " & vbNewLine & _
								"            ,[Style]                        " & vbNewLine & _
								"            ,[ElementID]                    " & vbNewLine & _
								"            ,[ElementType]                  " & vbNewLine & _
								"            ,[StrContent]                   " & vbNewLine & _
								"            ,[BinContent]                   " & vbNewLine & _
								"            ,[DocType]                      " & vbNewLine & _
								"            ,[Author]                       " & vbNewLine & _
								"            ,[Version]                      " & vbNewLine & _
								"            ,[IsActive]                     " & vbNewLine & _
								"            ,[Sequence]                     " & vbNewLine & _
								"            ,[DocDate])                     " & vbNewLine & _
								"      VALUES                                " & vbNewLine & _
								"            ('" & CreateGuid() & "'         " & vbNewLine & _
								"            ,'" & artifact.Name & "'        " & vbNewLine & _
								"            ,NULL                           " & vbNewLine & _
								"            ,NULL                           " & vbNewLine & _
								"            ,'" & artifact.ElementGUID & "' " & vbNewLine & _
								"            ,'SC_MessageProfile'            " & vbNewLine & _
								"            ,N'" & xmlString & "'           " & vbNewLine & _
								"            ,NULL                           " & vbNewLine & _
								"            ,'SC_MessageProfile'            " & vbNewLine & _
								"            ,'OCL to Schema Script'         " & vbNewLine & _
								"            ,NULL                           " & vbNewLine & _
								"            ,1                              " & vbNewLine & _
								"            ,0                              " & vbNewLine & _
								"            ,'" & timestamp & "')                "
			Repository.Execute sqlCreateSchemaDocument
	end function
	
	private function createArtifact()
		dim ownerPackage as EA.Package
		set ownerPackage = Repository.GetPackageByID(me.Context.PackageID)
		'add new artifact in owner package
		dim artifact as EA.Element
		set artifact = ownerPackage.Elements.AddNew(me.context.Name & "_Schema", "Artifact")
		artifact.Update
		'save the Schemacomposer property in the Style settings
		Repository.Execute "update t_object set Style = 'MessageProfile=1;' where ea_guid = '" & artifact.ElementGUID & "'"
		set createArtifact = artifact
	end function
	

	
	'processes the given ocl constraint and adds the required elements and properties to the schema
	public function processOCLs(OCLs, outputName)
		dim ocl
		on error resume next
		for each ocl in OCLs
			dim sourceProperty
			set sourceProperty = nothing
			'figure out which association end or attribute we are talking about
			dim sourceProperties
			set sourceProperties = findSource(ocl.LeftHand)
			if ocl.IsFacet  then
				'facets are defined on the content, but should result in a tagged value on the attribute that uses the BDT as type.
				if sourceProperties.Count > 1 then
					set sourceProperty = sourceProperties(1)
				end if
			else
				'other constraints are actually defined on the actual property
				if sourceProperties.Count > 0 then
					set sourceProperty = sourceProperties(0)
				end if
			end if
			'set the constraint (if any) on the source
			if not sourceProperty is nothing then
				processConstraint sourceProperty, ocl
			end if
			'report any errors
			if Err.Number <> 0 then
				Repository.WriteOutput outPutName, now() &  " Error processing OCL statement:'" & ocl.Statement & "' ->" & Err.Description, 0
				Err.Clear
			end if
		next
		'set error handling back to standard
		on error goto 0
		'add the missing attributes
		addMissingAttributes
		'remove the properties with maxOccurs = 0
		deleteNotNeededProperties
		'merge duplicate refines
		dim element
		for each element in me.Elements.Items
			element.mergeAllRedefines
		next
		
	end function
	
	'add the missing attributes for all «BDT» elements as they should always be part of the schema
	function addMissingAttributes()
		dim element
		for each element in me.Elements.Items
			if element.Source.Stereotype = "BDT" then 'TODO: check if really only needed for BDT's
				'loop all attributes and add them.
				dim attribute as EA.Attribute
				for each attribute in element.Source.Attributes
					createCorrespondingProperty attribute.Name, element
				next
			end if
		next
	end function
	
	'delete the properties that have a zero maxOccurs
	function deleteNotNeededProperties()
		dim element
		for each element in me.Elements.Items
			'then delete the properties that have a maxOccurs of 0
			dim schemaProperty
			for each schemaProperty in element.Properties.Items
				if schemaProperty.maxOccurs = "0" then
					schemaProperty.Delete
				end if
			next
		next
	end function

	
	
	private function processConstraint(sourceProperty, ocl)
		if not sourceProperty is nothing _
			and not ocl is nothing then
			'check the type of constraint
			select case ocl.ConstraintType
				case OCLEqual
					setEqualValue sourceProperty, ocl.rightHand
					'process next statement
					processConstraint sourceProperty, ocl.NextOCLStatement
				case OCLMultiplicity
					if trim(lcase(ocl.Operator)) = "->isempty()" then
						setMultiplicityValue sourceProperty, 0
					else
						setMultiplicityValue sourceProperty, ocl.rightHand
					end if
				case OCLChoice
					'report choice
					if not ocl.NextOCLStatement is nothing then
						Repository.WriteOutput outPutName, now() &  " Choice constraint found between :'" & ocl.leftHand & "' with GUID " & sourceProperty.GUID &_
									" with attribute '" & ocl.NextOCLStatement.LeftHand & "'",0
					else
						'invalid choice
						Err.Raise vbObjectError + 13, "processConstraint", " Invalid choice statement in OCL constraint '" & ocl.Statement & "'"
					end if
				case else
					'process facets
					if ocl.IsFacet then
						processFacetConstraint sourceProperty, ocl
					else
						'unknown constraint, should never happen
						Err.Raise vbObjectError + 14, "processConstraint", " ConstraintType:'" & ocl.Operator & "' is Unknown in OCL constraint '" & ocl.Statement & "'"
					end if
			end select
		end if
	end function
	
	private function processFacetConstraint(sourceProperty, ocl)
		'check if a tagged value for the facet already exists. If it does check if the value corresponds. If the value is different hen alert the user
		'get the taggedValueName for the facet
		dim facetTag as EA.TaggedValue
		set facetTag = getExistingOrNewTaggedValue(sourceProperty.Source, ocl.FacetName)
		'if the value is blank then simply fill it in
		if facetTag.Value = "" then
			facetTag.Value = replace(trim(ocl.RightHand), """","") 'we don't need any double quotes
			facetTag.Update
		elseif facetTag.Value <> replace(trim(ocl.RightHand), """","")  then
			Repository.WriteOutput outPutName, now() &  " Duplicate facet found for attribute with with GUID " & sourceProperty.GUID &_
									" Original facet: " & facetTag.Name & " -> " & facetTag.Value & _
									" OCL statement = '" & ocl.Statement & "'",0
		end if
	end function
	
	private function setEqualValue(sourceProperty, rightHandValue)
		if not sourceProperty.ClassifierSchemaElement is nothing then
			'remove any parentheses left
			rightHandValue = replace(rightHandValue, ")", "")
			'get the name of the property
			dim rightHandParts
			dim identifier
			rightHandParts = split(rightHandValue,"::")
			'gets the last value of the array
			identifier = rightHandParts(Ubound(rightHandParts))
			processIdentifierPart identifier, sourceProperty.ClassifierSchemaElement, true
		else
			Err.Raise vbObjectError + 11, "setEqualValue", "No ClassiferSchemaElement found for Property: '" & sourceProperty.Name & "' with GUID: '" & sourceProperty.GUID & "'"
		end if
	end function
	private function setMultiplicityValue(sourceProperty, rightHandValue)
		'if the right hand value is empty then it is an ->notEmpty() constraint -> minOccurs = 1
		if len(rightHandValue) = 0 then
			sourceProperty.minOccurs = "1"
		else
			if rightHandValue = "1" then
				sourceProperty.minOccurs = "1"
				sourceProperty.maxOccurs = "1"
			elseif lcase(trim(rightHandValue)) = "optional" then
				sourceProperty.minOccurs = "0"
			elseif len(rightHandValue) >= 3 _
				and left(rightHandValue,2) = "<=" then
				'find the actual value
				sourceProperty.maxOccurs = mid(rightHandValue,3)
			elseif trim(rightHandValue) = "0" then
				'set maxOccurs to 0
				sourceProperty.maxOccurs = "0"
			else
				Err.Raise vbObjectError + 12, "setMultiplicityValue", "Value '" & rightHandValue & "' not valid as multiplicityValue for Property: '" & sourceProperty.Name & "' with GUID: '" & sourceProperty.GUID & "'" 
			end if
		end if
	end function
	
	public function removeSchemaElement(element)
		if me.Elements.Exists(element.GUID) then
			if element.IsRedefinition then
				dim parentElement
				set parentElement = me.Elements.Item(element.GUID)
				'must be a redefined element
				parentElement.removeRedefine(element)
			else
				if element.Redefines.count = 0 then
					'do not delete elements that still have redefines
					me.Elements.Remove element.GUID
				end if
			end if
		end if	
	end function
	
	private function addSchemaElement(source, name, isNew)
		'add the context as a SchemaElement
		if not me.Elements.Exists(source.ElementGUID) then
			'create new schema Element
			dim schemaElement
			set schemaElement = new SchemaElement
			schemaElement.Source = source
			schemaElement.Name = name
			schemaElement.Schema = me
			'add it to the list
			me.Elements.Add schemaElement.GUID, schemaElement
			'return it
			set addSchemaElement = schemaElement
		else
			'element exists already
			dim existingElement
			set existingElement = me.Elements.Item(source.ElementGUID)
			dim test as EA.Element
			if isNew and existingElement.Source.Type = "Enumeration" then
				'add redefine and return it
				set addSchemaElement = existingElement.addNewRedefine()
			else
				'return it
				set addSchemaElement = existingElement
			end if
		end if
	end function
	
	private function findSource(identifierString)
		'split into parts 
		dim identifierParts
		identifierParts = split(identifierString, ".")
		dim identifierPart
		dim localContext as EA.Element
		set localContext = me.Context 'start with he MA as context
		dim contextSchemaElement
		set contextSchemaElement = addSchemaElement(localContext, localContext.Name, true)
		dim i
		dim correspondingProperty
		dim correspondingProperties
		set correspondingProperties = CreateObject("System.Collections.ArrayList")
		'start from the second one as the first one will be "self"
		for i = 1 to Ubound(identifierParts)
			identifierPart = identifierParts(i)
			set correspondingProperty = createCorrespondingProperty(identifierPart,contextSchemaElement)
			'set the context schema element
			set contextSchemaElement = correspondingProperty.ClassifierSchemaElement
			'add it to the list
			correspondingProperties.Add correspondingProperty
		next
		'reverse the list to make the last corresponding property the first
		correspondingProperties.Reverse
		'return
		set findSource = correspondingProperties
	end function
	function createCorrespondingProperty(identifierPart,contextSchemaElement)
		dim correspondingProperty
		dim localContext
		dim isNew
		set correspondingProperty = processIdentifierPart(identifierPart, contextSchemaElement, isNew)
		'set the new local context
		set localContext = correspondingProperty.Classifier
		if correspondingProperty.ClassifierSchemaElement is nothing then
			dim newContext
			'make sure the local context exists as SchemaElement
			set newContext = addSchemaElement(localContext, localContext.Name, isNew)
			'set the classifierSchemaElement on the correspondingProperty
			correspondingProperty.ClassifierSchemaElement = newContext
		end if
		'return property
		set createCorrespondingProperty = correspondingProperty
	end function 
	
	private function processIdentifierPart(identifierPart, contextSchemaElement, byRef isNew)
		'get the attribute or association starting from the localContext
		dim correspondingProperty
		set correspondingProperty = contextSchemaElement.getProperty(identifierPart, isNew)
		'return the corresponding property
		if correspondingProperty is nothing and identifierPart <> "content" then
			'check if there is an attribute name "content" and then process the identifierPart on that one
			dim contentProperty 
			set contentProperty = nothing 'initialize
			'turn off error checking
			on error resume next
			set contentProperty = createCorrespondingProperty("content",contextSchemaElement)
			'clear error and turn error checking back on
			if Err.Number <> 0 then
				Err.Clear
			end if
			on error goto 0
			'now try this property
			if not contentProperty is nothing then
				dim contentSchemaElement 
				set contentSchemaElement = contentProperty.ClassifierSchemaElement
				if not contentSchemaElement is nothing then
					set correspondingProperty = contentSchemaElement.getProperty(identifierPart, isNew)
				end if
			end if
			if correspondingProperty is nothing then
				'if still not found then raise error
				Err.Raise vbObjectError + 10, "processIdentifierPart", "Could not find '" & identifierPart & "' in the context of '" & contextSchemaElement.Name & "' with GUID : " & contextSchemaElement.GUID
			end if
		end if
		'return the corresponding property
		set processIdentifierPart = correspondingProperty
	end function
	
	public function tryGetElement(guid, byRef element)
		dim exists
		exists = me.Elements.Exists(guid)
		if exists then
			set element = me.Elements.Item(guid)
		end if
		tryGetElement = exists
	end function
	
	private function getXML()	
		set xmlDOM = CreateObject( "Microsoft.XMLDOM" )
		xmlDOM.validateOnParse = false
		xmlDOM.async = false
		
		dim node 
		set node = xmlDOM.createProcessingInstruction( "xml", "version='1.0'")
		xmlDOM.appendChild node
		
		dim xmlRoot 
		set xmlRoot = xmlDOM.createElement( "message" )
		xmlDOM.appendChild xmlRoot
		
		'add description node
		xmlRoot.appendChild createDescriptionNode(xmlDOM)
		
		'add schema node
		dim xmlSchema 
		set xmlSchema = xmlDOM.createElement("schema")
		'count attribute
		dim xmlcountAtttr 
		set xmlcountAtttr = xmlDOM.createAttribute("count")
		xmlcountAtttr.nodeValue = me.Elements.Count
		xmlSchema.setAttributeNode(xmlcountAtttr)
		'add the schema node to the root
		xmlRoot.appendChild xmlSchema
		'add all the elements to the schema
		dim element 
		for each element in me.Elements.Items
			'don't add elements that are not used
			if element.IsRoot _
				OR element.ReferencingProperties.Count > 0 _
				OR element.Redefines.Count > 0 then
				'add node
				xmlSchema.appendChild createElementNode(xmlDom, element)
			end if
		next
		
		'return xml string
		getXML = xmlDom.xml
	end function
	
	private function createDescriptionNode(xmlDOM)
		dim xmlDescription
		set xmlDescription = xmlDOM.createElement( "description" )
		
		'name attribute
		dim xmlNameAtttr 
		set xmlNameAtttr = xmlDOM.createAttribute("name")
		xmlNameAtttr.nodeValue = me.Context.Name & "_Schema"
		xmlDescription.setAttributeNode(xmlNameAtttr)
		
		'namespace attribute
		dim xmlnamespaceAtttr 
		set xmlnamespaceAtttr = xmlDOM.createAttribute("namespace")
		xmlnamespaceAtttr.nodeValue = ""
		xmlDescription.setAttributeNode(xmlnamespaceAtttr)
		
		'schemaset attribute
		dim xmlschemasetAtttr 
		set xmlschemasetAtttr = xmlDOM.createAttribute("schemaset")
		xmlschemasetAtttr.nodeValue = "ECDM Message Composer"
		xmlDescription.setAttributeNode(xmlschemasetAtttr)
		
		'provider attribute
		dim xmlproviderAtttr 
		set xmlproviderAtttr = xmlDOM.createAttribute("provider")
		xmlproviderAtttr.nodeValue = "ECDM Message Composer"
		xmlDescription.setAttributeNode(xmlproviderAtttr)
		
		'model attribute
		dim xmlmodelAtttr 
		set xmlmodelAtttr = xmlDOM.createAttribute("model")
		xmlmodelAtttr.nodeValue = Repository.ProjectGUID
		xmlDescription.setAttributeNode(xmlmodelAtttr)
		
		'modelURL attribute
		dim xmlmodelURLAtttr 
		set xmlmodelURLAtttr = xmlDOM.createAttribute("modelURL")
		xmlmodelURLAtttr.nodeValue = ""
		xmlDescription.setAttributeNode(xmlmodelURLAtttr)
		
		'version attribute
		dim xmlversionAtttr 
		set xmlversionAtttr = xmlDOM.createAttribute("version")
		xmlversionAtttr.nodeValue = "12.1.1230.1230" 
		xmlDescription.setAttributeNode(xmlversionAtttr)
		
		'xmlns attribute
		dim xmlxmlnsAtttr 
		set xmlxmlnsAtttr = xmlDOM.createAttribute("xmlns")
		xmlxmlnsAtttr.nodeValue = "OCL:"
		xmlDescription.setAttributeNode(xmlxmlnsAtttr)
		
		'type attribute
		dim xmltypeAtttr 
		set xmltypeAtttr = xmlDOM.createAttribute("type")
		xmltypeAtttr.nodeValue = "schema"
		xmlDescription.setAttributeNode(xmltypeAtttr)
		
		'auxiliary node
		dim xmlAuxiliary
		set xmlAuxiliary = xmlDOM.createElement( "auxiliary" )
		
		'xmlns attribute
		dim xmlxmlnsAtttrA 
		set xmlxmlnsAtttrA = xmlDOM.createAttribute("xmlns")
		xmlxmlnsAtttrA.nodeValue = ""
		xmlAuxiliary.setAttributeNode(xmlxmlnsAtttrA)
		'add auxiliary node
		xmlDescription.appendChild xmlAuxiliary
		
		'return node
		set createDescriptionNode = xmlDescription
	end function
	
	private function createElementNode(xmlDOM, element)
		dim xmlClass
		set xmlClass = xmlDOM.createElement( "class" )
		
		'name attribute
		dim xmlNameAtttr 
		set xmlNameAtttr = xmlDOM.createAttribute("name")
		xmlNameAtttr.nodeValue = element.Name
		xmlClass.setAttributeNode(xmlNameAtttr)
		
		'guid attribute
		dim xmlguidAtttr 
		set xmlguidAtttr = xmlDOM.createAttribute("guid")
		xmlguidAtttr.nodeValue = element.GUID
		xmlClass.setAttributeNode(xmlguidAtttr)
		
		'add the properties
		addProperties xmlDom, xmlClass, element
		
		'add redefines if needed
		addRedefines xmlDom, xmlClass, element
		
		'return node
		set createElementNode = xmlClass
	end function
	
	function addProperties (xmlDom, xmlClass, element)
		'create propertiesnode
		dim xmlProperties
		set xmlProperties= xmlDOM.createElement("properties")
		dim schemaProperty
		for each schemaProperty in element.Properties.Items
			xmlProperties.appendChild createPropertyNode (xmlDOM, schemaProperty)
		next
		'add xmlProperties to class node
		xmlClass.appendChild xmlProperties
	end function 
	
	function addRedefines (xmlDom, xmlClass, element)
		'only needed if any redefines exist
		if element.Redefines.Count > 0 then
			'create the redefines node
			dim xmlRedefine
			set xmlRedefine= xmlDOM.createElement("redefines")
			'loop the redefines
			dim redefine
			for each redefine in element.Redefines.Items
				'create the set node
				dim xmlSet
				set xmlSet = xmlDom.createElement("set")
				'add the attribute typename
				dim xmlTypeNameAttr
				set xmlTypeNameAttr = xmlDOM.createAttribute("typename")
				xmlTypeNameAttr.nodeValue = redefine.Name
				xmlSet.setAttributeNode(xmlTypeNameAttr)
				'add the properties for this redefined property
				dim schemaProperty
				for each schemaProperty in redefine.Properties.Items
					xmlSet.appendChild createPropertyNode (xmlDOM, schemaProperty)
				next
				'add the set node to the redefines node
				xmlRedefine.AppendChild xmlSet
			next
			'add the redefines node to the xmlClass node
			xmlClass.AppendChild xmlRedefine
		end if
	end function 

	private function createPropertyNode (xmlDOM, schemaProperty)
		dim xmlProperty
		set xmlProperty = xmlDOM.createElement("property")
		
		'guid attribute
		dim xmlguidAtttr 
		set xmlguidAtttr = xmlDOM.createAttribute("guid")
		xmlguidAtttr.nodeValue = schemaProperty.GUID
		xmlProperty.setAttributeNode(xmlguidAtttr)
		
		'type attribute
		dim xmltypeAtttr 
		set xmltypeAtttr = xmlDOM.createAttribute("type")
		xmltypeAtttr.nodeValue = lcase(schemaProperty.PropertyType)
		xmlProperty.setAttributeNode(xmltypeAtttr)
		
		'check if schemaProperty has a restriction
		if schemaProperty.IsRestricted then
			'type attribute
			dim xmlRestrictedAttr 
			set xmlRestrictedAttr = xmlDOM.createAttribute("restricted")
			xmlRestrictedAttr.nodeValue = "true"
			xmlProperty.setAttributeNode(xmlRestrictedAttr)
			
			'MinOccurs attribute
			dim xmlMinOccursAttr 
			set xmlMinOccursAttr = xmlDOM.createAttribute("minOccurs")
			xmlMinOccursAttr.nodeValue = schemaProperty.minOccurs
			xmlProperty.setAttributeNode(xmlMinOccursAttr)
			
			'maxOccurs attribute
			dim xmlMaxOccursAttr 
			set xmlMaxOccursAttr = xmlDOM.createAttribute("maxOccurs")
			xmlMaxOccursAttr.nodeValue = schemaProperty.maxOccurs
			xmlProperty.setAttributeNode(xmlMaxOccursAttr)
			
			'reDefines attribute
			dim xmlRedefinesAttr 
			set xmlRedefinesAttr = xmlDOM.createAttribute("redefines")
			xmlRedefinesAttr.nodeValue = schemaProperty.redefines
			xmlProperty.setAttributeNode(xmlRedefinesAttr)			

			'byRef attribute -> always 0
			dim xmlByRefAttr 
			set xmlByRefAttr = xmlDOM.createAttribute("byRef")
			xmlByRefAttr.nodeValue = "0"
			xmlProperty.setAttributeNode(xmlByRefAttr)
			
			'inline attribute -> always 0
			dim xmlInlineAttr 
			set xmlInlineAttr = xmlDOM.createAttribute("inline")
			xmlInlineAttr.nodeValue = "0"
			xmlProperty.setAttributeNode(xmlInlineAttr)			
		end if
		
		'return node
		set createPropertyNode = xmlProperty
	end function
	
end Class
'
' END: ../Framework/OCL/Schema.vbs
' #######################

'
' #######################
' BEGIN: ../Framework/OCL/SchemaElement.vbs

'[path=\Framework\OCL]
'[group=OCL]


'Author: Geert Bellekens
'Date: 2017-12-06
'Purpose: Class representing a Schema Element

Class SchemaElement 
	'private variables
	Private m_Source
	Private m_Name
	private m_IsRoot
	Private m_IsRedefinition
	Private m_Properties
	Private m_Redefines
	private m_ReferencingProperties
	private m_Schema
	
	'constructor
	Private Sub Class_Initialize
		m_Name = ""
		m_Name = ""
		m_isRoot = false
		m_IsRedefinition = false
		set m_Source = nothing
		set m_Schema = nothing
		set m_Properties = CreateObject("Scripting.Dictionary")
		set m_Redefines = CreateObject("Scripting.Dictionary")
		set m_ReferencingProperties = CreateObject("Scripting.Dictionary")
	End Sub
	
	' Source property. (EA.Element)
	Public Property Get Source
		set Source = m_Source
	End Property
	Public Property Let Source(value)
		set m_Source = value
		if m_Name = "" then
			m_Name = me.Source.Name
		end if
	End Property
	
	' Schema property OCL.Schema
	Public Property Get Schema
		set Schema = m_Schema
	End Property
	Public Property Let Schema(value)
		set m_Schema = value
	End Property
	
	' Name property.
	Public Property Get Name
		Name = m_Name
	End Property
	Public Property Let Name(value)
		m_Name = value
		'debug
		'Session.Output "Creating element : " & me.Name
	End Property
	
	' IsRoot property.
	Public Property Get IsRoot
		IsRoot = m_IsRoot
	End Property
	Public Property Let IsRoot(value)
		m_IsRoot = value
	End Property
	
	' IsRedefinition property. (boolean)
	Public Property Get IsRedefinition
		IsRedefinition = m_IsRedefinition
	End Property
	Public Property Let IsRedefinition(value)
		m_IsRedefinition = value
	End Property
	
	' Guid property.
	Public Property Get GUID
		GUID = me.Source.ElementGUID
	End Property
	
	' Properties property
	Public Property Get Properties
		set Properties = m_Properties
	End Property
	
	' Redefines property
	Public Property Get Redefines
		set Redefines = m_Redefines
	End Property
	
	' ReferencingProperties property. (Dictionary with GUID and SchemaProperties)
	Public Property Get ReferencingProperties
		set ReferencingProperties = m_ReferencingProperties
	End Property
	
	'add a referencing property
	public function addReferencingProperty(referencingProperty)
		if not me.ReferencingProperties.Exists(referencingProperty.GUID) then
			me.ReferencingProperties.Add referencingProperty.GUID, referencingProperty
			'debug
			'Session.Output "Adding referencing property: " & referencingProperty.Name & "with guid " & referencingProperty.GUID & " to element " & me.Name
		end if
	end function
	
	'remove a referencing property
	public function removeReferencingProperty(referencingProperty)
		if me.ReferencingProperties.Exists(referencingProperty.GUID) then
			me.ReferencingProperties.Remove referencingProperty.GUID
			'debug
			'Session.Output "Removing referencing property: " & referencingProperty.Name & "with guid " & referencingProperty.GUID & " from element " & me.Name
			if me.ReferencingProperties.Count = 0  _
				AND me.Redefines.Count = 0 then
				Delete
			end if
		end if	
	end function
	
	public function Delete()
		'debug
		'Session.Output "Deleting element " & me.Name
		'first delete all owned properties
		dim schemaProperty
		for each schemaProperty in me.Properties.Items
			schemaProperty.Delete
		next
		'then remove me from the schema
		me.Schema.RemoveSchemaElement me
		'and remove me from the parent redefine
	end function
	
	'Merges redefines that have the same properties.
	public function mergeAllRedefines()
		dim redefine
		dim i
		dim redefinesToDelete
		set redefinesToDelete = CreateObject("System.Collections.ArrayList")
		for i = me.Redefines.Count -1 to 0 step -1 
			set redefine = me.Redefines.Items()(i)
			dim merged
			'compare with me
			merged = mergeRedefines(me, redefine)
			if not merged then
				'loop the redefines again to find equals
				dim otherRedefine
				for each otherRedefine in me.Redefines.Items
					 merged = mergeRedefines(otherRedefine, redefine)
				next
			end if
			'if merged then add the redefine to the list of redefines to delete
			if merged then
				removeRedefine redefine
			end if
		next
		'at the end, if this element doesn't have any referencing properties then replace it with the first redefine that has any
		if me.ReferencingProperties.Count = 0 then
			for each redefine in me.Redefines.items
				if redefine.ReferencingProperties.Count > 0 then
					'replace the properties properties
					me.Properties.RemoveAll
					dim redefinedProperty
					for each redefinedProperty in redefine.Properties.Items
						'add to properties list
						me.Properties.Add redefinedProperty.GUID, redefinedProperty
						'set me as owner
						redefinedProperty.Owner = me
					next
					dim usingProperty
					'set using properties to me
					for each usingProperty in redefine.ReferencingProperties.Items
						usingProperty.ClassifierSchemaElement = me
					next
					'delete redefine
					removeRedefine redefine
					'exit the for loop
					exit for
				end if
			next
		end if
	end function
	
	private function mergeRedefines(redefineToKeep, redefineToDelete)
		'default false
		mergeRedefines = false
		'compare names
		if redefineToKeep.Name = redefineToDelete.Name then
			'don't even start if it's the same redefine
			exit function
		end if
		if isEquivalentRedefine(redefineToKeep, redefineToDelete) then
			'merge the two redefines, keeping redefineToKeep
			dim usingProperty
			'set the using properties to use redefineToKeep
			for each usingProperty in redefineToDelete.ReferencingProperties.Items
				usingProperty.ClassifierSchemaElement = redefineToKeep
			next
			mergeRedefines = true
		end if
	end function
	
	private function isEquivalentRedefine(redefine, otherRedefine)
		isEquivalentRedefine = true
		dim schemaProperty
		'first check if they have the same number of properties
		if redefine.Properties.Count <> otherRedefine.Properties.Count then
			isEquivalentRedefine = false
			exit function
		end if
		'then compare each property
		for each schemaProperty in redefine.Properties.Items
			dim found
			found = false
			dim otherProperty
			for each otherProperty in otherRedefine.Properties.Items
				if schemaProperty.GUID = otherProperty.GUID then
					found = true
				end if
			next
			'if we haven't found an equal property then we exit
			if not found then
				isEquivalentRedefine = false
				exit for
			end if
		next
	end function

	public function deleteProperty(propertyToDelete)
		if not propertyToDelete is nothing then
			if me.Properties.Exists(propertyToDelete.GUID) then
				me.Properties.Remove(propertyToDelete.GUID)
			end if
		end if
	end function
	
	public function getProperty(identifierPart, Byref isNew)
		'initialize null
		set getProperty = nothing
		'clean identifierPart (remove quotes)
		dim cleanIdentifier
		cleanIdentifier = replace(trim(identifierPart),"'","")
		'first check if there is an attribute on the localContext with the given name
		dim sqlGetAttribute
		sqlGetAttribute = "select a.ID from t_attribute a " & _
						" where a.Object_ID = " & me.Source.ElementID  & _
						" and a.Name = '" & cleanIdentifier & "' "
		'get the attribute
		dim attributes
		set attributes = getattributesFromQuery(sqlGetAttribute)
		if attributes.Count > 0 then
			'return the first attribute
			set getProperty = me.addAttributeProperty(attributes(0), isNew)
		else
			'get association end
			dim associationEnd
			set associationEnd = nothing
			'first check target end
			dim sqlGetTargetEnd
			sqlGetTargetEnd	= "select c.Connector_ID from t_connector c" & _
							" where c.Start_Object_ID = " & me.Source.ElementID  & _
							" and c.DestRole = '" & cleanIdentifier & "' "
			dim connector as EA.Connector
			dim connectors
			set connectors = getConnectorsFromQuery(sqlGetTargetEnd)
			if connectors.Count > 0 then
				set connector = connectors(0)
				set associationEnd = connector.SupplierEnd
			else
				'then source end
				dim sqlGetSourceEnd
				sqlGetSourceEnd = "select c.Connector_ID from t_connector c" & _
							" where c.End_Object_ID = " & me.Source.ElementID  & _
							" and c.SourceRole = '" & cleanIdentifier & "' "
				set connectors = getConnectorsFromQuery(sqlGetSourceEnd)
				if connectors.Count > 0 then
					set connector = connectors(0)
					set associationEnd = connector.ClientEnd
				end if
			end if
			'create the SchemeProperty
			if not associationEnd is nothing then
				set getProperty = me.addConnectorEndProperty(associationEnd, connector, isNew)
			end if
		end if
		'set owner of the property
		if not getProperty is nothing then
			getProperty.Owner = me
		end if
	end function
		
	' Add Attribute poperty to properties
	Public function addAttributeProperty(newAttribute, Byref isNew)
		if me.Properties.Exists(newAttribute.AttributeGUID) then
			'return existing item
			set addAttributeProperty = me.Properties.Item(newAttribute.AttributeGUID)
			isNew = false
		else
			'create new item
			dim newProperty
			set newProperty = new SchemaProperty
			newProperty.Source = newAttribute
			me.Properties.Add newProperty.GUID, newProperty
			isNew = true
			'return new item
			set addAttributeProperty = newProperty
		end if
	End function
	
	' Add Attribute poperty to properties
	Public function addConnectorEndProperty(newConnectorEnd, newConnector, Byref isNew)
		if me.Properties.Exists(newConnector.ConnectorGUID) then
			'return existing item
			set addConnectorEndProperty = me.Properties.Item(newConnector.ConnectorGUID)
			isNew = false
		else
			'create new item
			dim newProperty
			set newProperty = new SchemaProperty
			newProperty.Source = newConnectorEnd
			newProperty.Connector = newConnector
			me.Properties.Add newProperty.GUID, newProperty
			isNew = true
			'return new item
			set addConnectorEndProperty = newProperty
		end if
	End function
	
	' Add a redefines  element
	Private function addRedefine(newRedefine)
		if not m_Redefines.Exists(newRedefine.Name) then
			m_Redefines.Add newRedefine.Name, newRedefine
		end if
	End function
	'removes a redefine
	public function removeRedefine(redefine)
		'debug
		'Session.Output "Request remove redefine " & redefine.Name
		if me.Redefines.Exists(redefine.Name) then
			me.Redefines.Remove redefine.Name
			'debug
			'Session.Output "Actually removing redefine " & redefine.Name
		end if
	end function
	'adds a new redefine
	public function addNewRedefine()
		'create new schemaElement
		dim newRedefine
		set newRedefine = new SchemaElement
		newRedefine.Name = me.Name & "_" & m_Redefines.Count + 1
		newRedefine.Source = me.Source
		newRedefine.Schema = me.Schema
		newRedefine.IsRedefinition = true
		'add it to the list of redefines
		addRedefine newRedefine
		'return it
		set addNewRedefine = newRedefine
	end function

end Class
'
' END: ../Framework/OCL/SchemaElement.vbs
' #######################

'
' #######################
' BEGIN: ../Framework/OCL/SchemaProperty.vbs

'[path=\Framework\OCL]
'[group=OCL]

!INC Local Scripts.EAConstants-VBScript

'Author: Geert Bellekens
'Date: 2017-12-06
'Purpose: Class representing a Schema Property


Class SchemaProperty
	'private variables
	Private m_Source
	Private m_Connector
	Private m_minOccurs
	Private m_maxOccurs
	Private m_Classifier
	Private m_ClassifierSchemaElement
	Private m_Owner
	
	
	'constructor
	Private Sub Class_Initialize
		set m_Source = nothing
		set m_Connector = nothing
		set m_Classifier = nothing
		set m_ClassifierSchemaElement= nothing
		set m_Owner = nothing
		m_minOccurs = ""
		m_maxOccurs = ""
	End Sub
	
	'Properties
	' Source property. (EA.Attribute or EA.ConnectorEnd)
	Public Property Get Source
	  set Source = m_Source
	End Property
	Public Property Let Source(value)
	  set m_Source = value
	  set m_Classifier = nothing
	End Property
	
	' Connector property. (EA.Connector)
	Public Property Get Connector
	  set Connector = m_Connector
	End Property
	Public Property Let Connector(value)
	  set m_Connector = value
	End Property
	
	' PropertyType property.
	Public Property Get PropertyType
		if me.Source.ObjectType = otAttribute then
			PropertyType = "Attribute"
		else
			PropertyType = "Association"
		end if
	End Property
	
	' GUID property
	Public Property Get GUID
		if me.PropertyType = "Attribute" then
			GUID = me.Source.AttributeGUID
		else
			GUID = me.Connector.ConnectorGUID
		end if
	End Property
	
	' Name property.
	Public Property Get Name
		if me.PropertyType = "Attribute" then
			Name = me.Source.Name
		else
			Name = me.Source.Role
		end if
	End Property
	
	' minOccurs property
	Public Property Get minOccurs
		if len(m_minOccurs) > 0 then
			minOccurs = m_minOccurs
		else
			minOccurs = getSourceLowerBound()
		end if
	End Property
	Public Property Let minOccurs(value)
	  m_minOccurs = value
	End Property
	
	' maxOccurs property
	Public Property Get maxOccurs
		if len(m_maxOccurs) > 0 then
			maxOccurs = m_maxOccurs
		else
			maxOccurs = getSourceUpperBound()
		end if
	End Property
	Public Property Let maxOccurs(value)
	  m_maxOccurs = value
	End Property
	
	' return the name of the redefined schema element
	Public Property Get Redefines
		Redefines = ""
		if not me.ClassifierSchemaElement is nothing then
			if me.ClassifierSchemaElement.IsRedefinition then
				Redefines = me.ClassifierSchemaElement.Name
			end if
		end if
	End Property

	' Restricted property (Boolean)
	Public Property Get IsRestricted
		'default
		IsRestricted = false
		'check if lowerbound is filled in and different
		if len(m_minOccurs) > 0 _
		  and m_minOccurs <> getSourceLowerBound() then
			IsRestricted = true
	    end if
		'check if upperbound is filled in and different
		if len(m_maxOccurs) > 0 _
		  and m_maxOccurs <> getSourceUpperBound() then
			IsRestricted = true
	    end if
		'check if uses Redefined element
		if len(me.Redefines) > 0 then
			IsRestricted = true
		end if
	End Property
	
	' Classifier property (EA.Element)
	Public Property Get Classifier
		'lazy loading
		if m_Classifier is nothing then
			if me.PropertyType = "Attribute" then
				set m_Classifier = Repository.GetElementByID(me.Source.ClassifierID)
			else
				dim e as EA.ConnectorEnd
				if me.Source.End = "Supplier" then
					set m_Classifier = Repository.GetElementByID(me.Connector.SupplierID)
				else
					set m_Classifier = Repository.GetElementByID(me.Connector.ClientID)
				end if
			end if
		end if
		set Classifier = m_Classifier
	End Property
	
	' ClassifierSchemaElement property. (SchemaElement)
	Public Property Get ClassifierSchemaElement
	  set ClassifierSchemaElement = m_ClassifierSchemaElement
	End Property
	Public Property Let ClassifierSchemaElement(value)
	  set m_ClassifierSchemaElement = value
	  'add me as referencing property to the schema element
	  m_ClassifierSchemaElement.addReferencingProperty me
	End Property
	
	' Owner property (SchemaElement)
	Public Property Get Owner
	  set Owner = m_Owner
	End Property
	Public Property Let Owner(value)
	  set m_Owner = value
	End Property
	

	'Public Functions
	'Delete this property by removing it from its owner and from the referencing properties lis of the classifier
	public function Delete
		'debug
		'Session.Output "Deleting property: " & me.Name
		me.Owner.deleteProperty me
		if not me.ClassifierSchemaElement is nothing then
			me.ClassifierSchemaElement.removeReferencingProperty me
		end if
	end function
	
	'Private Functions
	private function getSourceLowerBound()
		if me.PropertyType = "Attribute" then
			getSourceLowerBound = me.Source.LowerBound
			if len(getSourceLowerBound) = 0 then
				'default 1 for attributes
				getSourceLowerBound = "1"
			end if			
		else
			getSourceLowerBound = getAssociationEndLowerBound()
		end if
	end function
	private function getSourceUpperBound()
		if me.PropertyType = "Attribute" then
			getSourceUpperBound = me.Source.UpperBound
			if len(getSourceUpperBound) = 0 then
				'default 1 for attributes
				getSourceUpperBound = "1"
			end if
		else
			getSourceUpperBound = getAssociationEndUpperBound()
		end if
	end function
	
	private function getAssociationEndLowerBound()
		dim cardinalityParts
		cardinalityParts = split(me.Source.Cardinality,"..")
		if Ubound(cardinalityParts) = 1 then
			getAssociationEndLowerBound = cardinalityParts(0)
		else
			getAssociationEndLowerBound = me.Source.Cardinality
		end if
		'default lowerbound = 0
		if len(getAssociationEndLowerBound) = 0 then
			getAssociationEndLowerBound = "0"
		end if
	end function
	private function getAssociationEndUpperBound()
		dim cardinalityParts
		cardinalityParts = split(me.Source.Cardinality,"..")
		if Ubound(cardinalityParts) = 1 then
			getAssociationEndUpperBound = cardinalityParts(1)
		else
			getAssociationEndUpperBound = me.Source.Cardinality
		end if
		'default upperbound = *
		if len(getAssociationEndUpperBound) = 0 then
			getAssociationEndUpperBound	= "*"
		end if
	end function
	
end Class
'
' END: ../Framework/OCL/SchemaProperty.vbs
' #######################

'
' END: ../Framework/OCL/Include.vbs
' #######################

'Author: Geert Bellekens
'Date: 2015-12-07
'
' END: ../Framework/Wrappers/Include.vbs
' #######################

'
' #######################
' BEGIN: ../Framework/Utils/LocalPaths.vbs

'[path=\Framework\utils]
'[group=Utils]

' Already inlined !INC Utils.Util

'
' Given an id "byId" return that local path defined in %APPDATA%\Sparx Systems\EA\paths.txt
' if no id matches then return an empty string
'
function LocalPathsToPathForId(byId)
    LocalPathsToPathForId = ""

    dim shell
    Set shell = CreateObject( "WScript.Shell" )
    dim appDataPath
    appDataPath = shell.ExpandEnvironmentStrings("%APPDATA%")
    dim pathsFile
    set pathsFile = new TextFile
    pathsFile.FullPath = appDataPath & "\Sparx Systems\EA\paths.txt"
    pathsFile.loadContents
    dim pathsLines
    pathsLines = Split(pathsFile.Contents, vbCrLf)
    dim pathLine
    for each pathLine in pathsLines
        dim pathId
        pathId = getValueForkey(pathLine, "id")
        if pathId = byId then
            LocalPathsToPathForId = getValueForkey(pathLine, "path")
            exit function
        end if
    next
end function
'
' END: ../Framework/Utils/LocalPaths.vbs
' #######################

!INC EAScriptLib.VBScript-GUID

' Author: Geert Bellekens
' Purpose: Loads scripts from the file systems and stores them in Enterprise Architect
' Date: 2015-12-07
'

dim allScriptsInSparxModel, allGroupsInSparxModel, overwriteExisting, scriptsFolder

sub init
    dim script

    overwriteExisting = "undecided"
    set allGroupsInSparxModel = Nothing

    'first get all existing scripts and groups
    set script = new Script
    set allScriptsInSparxModel = script.getAllScripts(allGroupsInSparxModel)

    scriptsFolder = LocalPathsToPathForId("EA-Matic Script Folder")
end sub

sub main
	dim selectedFolder
	set selectedFolder = new FileSystemFolder
	set selectedFolder = selectedFolder.getUserSelectedFolder(scriptsFolder)
	if not selectedFolder is nothing then
		'get the scripts from the folder and its subfolders
                Session.Output "Loading scripts from folder: " & selectedFolder.FullPath
		getScriptsFromFolder selectedFolder
	end if
end sub

'gets all the scripts from the given folder and its subfolders (if any)
function getScriptsFromFolder(selectedFolder)
	dim file, script, subFolder
	for each file in selectedFolder.TextFiles
		Session.Output "FileName: " & file.FileName
		'Session.Output "Code: " & file.Contents
		set script = getScriptFromFile(file)
		if overwriteExisting = vbCancel then
			exit for
		end if
	next
	'then process subfolders
	if not overwriteExisting = vbCancel then
		for each subFolder in selectedFolder.SubFolders
			getScriptsFromFolder subFolder
		next
	end if
end function

function getScriptFromFile(file)
	dim script, newScript, foundMatch, newScriptGroupName, group, foundGroup
	foundMatch = false
	foundGroup = false
	set group = nothing
	set script = Nothing

        set newScript = new Script
        newScript.Name = file.FileNameWithoutExtension
        newScript.Code = file.Contents
        newScriptGroupName = newScript.GroupInNameCode

	if file.Extension = "vbs" then
		for each script in allScriptsInSparxModel
			'check the name of the script
			if script.Name = newScript.Name then
				'if the groupname was not found in the code we use the name of the package
				if len(newScriptGroupName) = 0 then
					newScriptGroupName = file.Folder.Name
				end if
				'check if there is a groupname defined in the file
				if script.Group.Name = newScriptGroupName then
					'we have a match
					foundMatch = true
					set group = script.Group
					exit for
				end if
			end if
		next
		if not foundMatch then
			'script did not exist yet
			'figure out if the group exists already
			for each group in allGroupsInSparxModel.Items
				if group.Name = newScriptGroupName then
					'found the group
					'add the group to the new script
					newScript.Group = group
					checkGroupTypeAndOverwrite group, newScript
					foundGroup = true
					exit for
				end if
			next
			'if the group doesn't exist yet we have to create it
			if not foundGroup then
				set group = new ScriptGroup
				group.Name = newScriptGroupName
				group.GUID = GUIDGenerateGUID()
				group.GroupType = newScript.GroupType
				'create the Group in the database
				group.Create
				'refresh allGroupsInSparxModel
				set allGroupsInSparxModel = group.GetAllGroups()
				'add the group to the script
				newScript.Group = group
			end if
			'Now we have to create the script
			newScript.GUID = GUIDGenerateGUID()
			newScript.Create
			set script = newScript
		else
			if overwriteExisting = "undecided" then
				overwriteExisting = Msgbox("Do you want to update existing scripts?", vbYesNoCancel+vbQuestion, "Update existing scripts")
			end if
			if overwriteExisting = vbYes then
				checkGroupTypeAndOverwrite group, newScript
				script.Code = newScript.Code
				script.Update
			end if
		end if

	end if
	set getScriptFromFile = script
end function

sub checkGroupTypeAndOverwrite(group, newScript)
	if group.GroupType <> newScript.GroupType then
		dim updateGroupType
		updateGroupType = Msgbox("Update Group " & group.Name & " from GroupType=" & group.GroupType & " to new GroupType=" & newScript.GroupType & "?", vbYesNoCancel+vbQuestion, "Script group type does not match Group group type")
		if updateGroupType = vbYes then
			group.GroupType = newScript.GroupType
			group.Update
		end if
	end if
end sub

init
'
' END: ../Framework/Tools/Script Management/LoadScripts.vbs
' #######################

dim fileToLoad
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Wrappers\Include.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Wrappers\Messaging\MessageValidationRule.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Utils\XML.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Utils\ModelInfo.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\OCL\SchemaProperty.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Wrappers\Scripting\SearchResults.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Utils\EA Enums.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Utils\ExcelFile.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Wrappers\Scripting\Script.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\OCL\Schema.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Utils\BinaryFile.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Utils\Util.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Wrappers\Messaging\MessageNode.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Utils\LocalPaths.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Utils\Include.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Wrappers\Messaging\Include.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Wrappers\TaggedValues\TaggedValue.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\OCL\Include.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Utils\DocGenHelpers.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Wrappers\Messaging\Message.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\OCL\SchemaElement.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Wrappers\Scripting\ScriptGroup.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\OCL\OCLStatement.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Utils\TextFile.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Utils\SQL.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Utils\FileSystemFolder.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Utils\FileSystem.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
set fileToLoad = new TextFile
fileToLoad.FullPath = scriptsFolder & "\Framework\Tools\Script Management\LoadScripts.vbs"
fileToLoad.loadContents()
getScriptFromFile(fileToLoad)
Session.output "LoadScriptsBootstrap: finished."
